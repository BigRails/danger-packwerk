# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `claide-plugins` gem.
# Please instead update this file by running `bin/tapioca gem claide-plugins`.

# The mods of interest are {CLAide::ARGV}, {CLAide::Command}, and
# {CLAide::InformativeError}
module CLAide; end

# This class is used to build a command-line interface
#
# Each command is represented by a subclass of this class, which may be
# nested to create more granular commands.
#
# Following is an overview of the types of commands and what they should do.
#
# ### Any command type
#
# * Inherit from the command class under which the command should be nested.
# * Set {Command.summary} to a brief description of the command.
# * Override {Command.options} to return the options it handles and their
#   descriptions and prepending them to the results of calling `super`.
# * Override {Command#initialize} if it handles any parameters.
# * Override {Command#validate!} to check if the required parameters the
#   command handles are valid, or call {Command#help!} in case they’re not.
#
# ### Abstract command
#
# The following is needed for an abstract command:
#
# * Set {Command.abstract_command} to `true`.
# * Subclass the command.
#
# When the optional {Command.description} is specified, it will be shown at
# the top of the command’s help banner.
#
# ### Normal command
#
# The following is needed for a normal command:
#
# * Set {Command.arguments} to the description of the arguments this command
#   handles.
# * Override {Command#run} to perform the actual work.
#
# When the optional {Command.description} is specified, it will be shown
# underneath the usage section of the command’s help banner. Otherwise this
# defaults to {Command.summary}.
class CLAide::Command
  # Subclasses should override this method to remove the arguments/options
  # they support from `argv` _before_ calling `super`.
  #
  # The `super` implementation sets the {#verbose} attribute based on whether
  # or not the `--verbose` option is specified; and the {#ansi_output}
  # attribute to `false` if {Command.ansi_output} returns `true`, but the
  # user specified the `--no-ansi` option.
  #
  # @param argv [ARGV, Array] A list of (user-supplied) params that should be handled.
  # @return [Command] a new instance of Command
  def initialize(argv); end

  # Set to `true` if {Command.ansi_output} returns `true` and the user
  # did **not** specify the `--no-ansi` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Whether or not to use ANSI codes to prettify output. For instance, by
  #   default {InformativeError} exception messages will be colored red and
  #   subcommands in help banners green.
  def ansi_output; end

  # Set to `true` if {Command.ansi_output} returns `true` and the user
  # did **not** specify the `--no-ansi` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Whether or not to use ANSI codes to prettify output. For instance, by
  #   default {InformativeError} exception messages will be colored red and
  #   subcommands in help banners green.
  def ansi_output=(_arg0); end

  # Set to `true` if {Command.ansi_output} returns `true` and the user
  # did **not** specify the `--no-ansi` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Whether or not to use ANSI codes to prettify output. For instance, by
  #   default {InformativeError} exception messages will be colored red and
  #   subcommands in help banners green.
  def ansi_output?; end

  # Handles root commands options if appropriate.
  #
  # @param argv [ARGV] The parameters of the command.
  # @return [Bool] Whether any root command option was handled.
  def handle_root_options(argv); end

  # Set to `true` if initialized with a `--help` flag
  #
  # @return [Boolean] Whether the command was initialized with argv containing --help
  def help?; end

  # Set to `true` if initialized with a `--help` flag
  #
  # @return [Boolean] Whether the command was initialized with argv containing --help
  def help_arg; end

  # Set to `true` if initialized with a `--help` flag
  #
  # @return [Boolean] Whether the command was initialized with argv containing --help
  def help_arg=(_arg0); end

  # @return [Bool] Whether the command was invoked by an abstract command by
  #   default.
  def invoked_as_default; end

  # @return [Bool] Whether the command was invoked by an abstract command by
  #   default.
  def invoked_as_default=(_arg0); end

  # @return [Bool] Whether the command was invoked by an abstract command by
  #   default.
  def invoked_as_default?; end

  # Prints the version of the command optionally including plugins.
  def print_version; end

  # This method should be overridden by the command class to perform its
  # work.
  #
  # @return [void]
  def run; end

  # Raises a Help exception if the `--help` option is specified, if `argv`
  # still contains remaining arguments/options by the time it reaches this
  # implementation, or when called on an ‘abstract command’.
  #
  # Subclasses should call `super` _before_ doing their own validation. This
  # way when the user specifies the `--help` flag a help banner is shown,
  # instead of possible actual validation errors.
  #
  # @raise [Help]
  # @return [void]
  def validate!; end

  # Set to `true` if the user specifies the `--verbose` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Wether or not backtraces should be included when presenting the user an
  #   exception that includes the {InformativeError} module.
  def verbose; end

  # Set to `true` if the user specifies the `--verbose` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Wether or not backtraces should be included when presenting the user an
  #   exception that includes the {InformativeError} module.
  def verbose=(_arg0); end

  # Set to `true` if the user specifies the `--verbose` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Wether or not backtraces should be included when presenting the user an
  #   exception that includes the {InformativeError} module.
  def verbose?; end

  protected

  # Print banner and exit
  #
  # @note Calling this method exits the current process.
  # @return [void]
  def banner!; end

  # @param error_message [String] A custom optional error message
  # @raise [Help] Signals CLAide that a help banner for this command should be shown,
  #   with an optional error message.
  # @return [void]
  def help!(error_message = T.unsafe(nil)); end

  # Returns the class of the invoked command
  #
  # @return [Command]
  def invoked_command_class; end

  class << self
    # @return [Boolean] Indicates whether or not this command can actually
    #   perform work of itself, or that it only contains subcommands.
    def abstract_command; end

    # @return [Boolean] Indicates whether or not this command can actually
    #   perform work of itself, or that it only contains subcommands.
    def abstract_command=(_arg0); end

    # @return [Boolean] Indicates whether or not this command can actually
    #   perform work of itself, or that it only contains subcommands.
    def abstract_command?; end

    # @return [Boolean] The default value for {Command#ansi_output}. This
    #   defaults to `true` if `STDOUT` is connected to a TTY and
    #   `String` has the instance methods `#red`, `#green`, and
    #   `#yellow` (which are defined by, for instance, the
    #   [colored](https://github.com/defunkt/colored) gem).
    def ansi_output; end

    # Sets the attribute ansi_output
    #
    # @param value the value to set the attribute ansi_output to.
    def ansi_output=(_arg0); end

    # @return [Boolean] The default value for {Command#ansi_output}. This
    #   defaults to `true` if `STDOUT` is connected to a TTY and
    #   `String` has the instance methods `#red`, `#green`, and
    #   `#yellow` (which are defined by, for instance, the
    #   [colored](https://github.com/defunkt/colored) gem).
    def ansi_output?; end

    # @return [Array<Argument>] A list of arguments the command handles. This is shown
    #   in the usage section of the command’s help banner.
    #   Each Argument in the array represents an argument by its name
    #   (or list of alternatives) and whether it's required or optional
    def arguments; end

    # @param arguments [Array<Argument>] An array listing the command arguments.
    #   Each Argument object describe the argument by its name
    #   (or list of alternatives) and whether it's required or optional
    # @todo Remove deprecation
    def arguments=(arguments); end

    # Handle deprecated form of self.arguments as an
    # Array<Array<(String, Symbol)>> like in:
    #
    #   self.arguments = [ ['NAME', :required], ['QUERY', :optional] ]
    #
    # @todo Remove deprecated format support
    def arguments_array=(arguments); end

    # Handle deprecated form of self.arguments as a String, like in:
    #
    #   self.arguments = 'NAME [QUERY]'
    #
    # @todo Remove deprecated format support
    def arguments_string=(arguments); end

    # Returns the banner for the command.
    #
    # @param banner_class [Class] The class to use to format help banners.
    # @return [String] The banner for the command.
    def banner(banner_class = T.unsafe(nil)); end

    # Print banner and exit
    #
    # @note Calling this method exits the current process.
    # @return [void]
    def banner!; end

    # @return [String] The name of the command. Defaults to a snake-cased
    #   version of the class’ name.
    def command; end

    # Sets the attribute command
    #
    # @param value the value to set the attribute command to.
    def command=(_arg0); end

    # @return [String] The subcommand which an abstract command should invoke
    #   by default.
    def default_subcommand; end

    # @return [String] The subcommand which an abstract command should invoke
    #   by default.
    def default_subcommand=(_arg0); end

    # @return [String] A longer description of the command, which is shown
    #   underneath the usage section of the command’s help banner. Any
    #   indentation in this value will be ignored.
    def description; end

    # @return [String] A longer description of the command, which is shown
    #   underneath the usage section of the command’s help banner. Any
    #   indentation in this value will be ignored.
    def description=(_arg0); end

    # Searches the list of subcommands that should not be ignored for command
    # lookup for a subcommand with the given `name`.
    #
    # @param name [String] The name of the subcommand to be found.
    # @return [CLAide::Command, nil] The subcommand, if found.
    def find_subcommand(name); end

    # @example
    #
    #   BevarageMaker::Tea.full_command # => "beverage-maker tea"
    # @return [String] The full command up-to this command, as it would be
    #   looked up during parsing.
    def full_command; end

    # Presents an exception to the user in a short manner in case of an
    # `InformativeError` or in long form in other cases,
    #
    # @param command [Command, nil] The command from where the exception originated.
    # @param exception [Object] The exception to present.
    # @return [void]
    def handle_exception(command, exception); end

    # @param error_message [String] The error message to show to the user.
    # @param help_class [Class] The class to use to raise a ‘help’ error.
    # @raise [Help] Signals CLAide that a help banner for this command should be shown,
    #   with an optional error message.
    # @return [void]
    def help!(error_message = T.unsafe(nil), help_class = T.unsafe(nil)); end

    # @return [Boolean] Indicates whether or not this command is used during
    #   command parsing and whether or not it should be shown in the
    #   help banner or to show its subcommands instead.
    #
    #   Setting this to `true` implies it’s an abstract command.
    def ignore_in_command_lookup; end

    def ignore_in_command_lookup=(flag); end

    # @return [Boolean] Indicates whether or not this command is used during
    #   command parsing and whether or not it should be shown in the
    #   help banner or to show its subcommands instead.
    #
    #   Setting this to `true` implies it’s an abstract command.
    def ignore_in_command_lookup?; end

    # Automatically registers a subclass as a subcommand.
    def inherited(subcommand); end

    # Convenience method.
    # Instantiate the command and run it with the provided arguments at once.
    #
    # CLAide::Command::run, it does not load plugins nor exit on failure.
    # It is up to the caller to rescue any possible exception raised.
    #
    # @note This method validate! the command before running it, but contrary to
    # @param args [String..., Array<String>] The arguments to initialize the command with
    # @raise [Help] If validate! fails
    def invoke(*args); end

    # @param argv [Array, ARGV] A list of (remaining) parameters.
    # @return [Command] Returns the default subcommand initialized with the
    #   given arguments.
    def load_default_subcommand(argv); end

    # Should be overridden by a subclass if it handles any options.
    #
    # The subclass has to combine the result of calling `super` and its own
    # list of options. The recommended way of doing this is by concatenating
    # to this classes’ own options.
    #
    # @example
    #
    #   def self.options
    #   [
    #   ['--verbose', 'Print more info'],
    #   ['--help',    'Print help banner'],
    #   ].concat(super)
    #   end
    # @return [Array<Array>] A list of option name and description tuples.
    def options; end

    # @param argv [Array, ARGV] A list of (remaining) parameters.
    # @return [Command] An instance of the command class that was matched by
    #   going through the arguments in the parameters and drilling down
    #   command classes.
    def parse(argv); end

    # Handle depracted form of assigning a plugin prefix.
    #
    # @todo Remove deprecated form.
    def plugin_prefix=(prefix); end

    # @return [Array<String>] The prefixes used to search for CLAide plugins.
    #   Plugins are loaded via their `<plugin_prefix>_plugin.rb` file.
    #   Defaults to search for `claide` plugins.
    def plugin_prefixes; end

    # Sets the attribute plugin_prefixes
    #
    # @param value the value to set the attribute plugin_prefixes to.
    def plugin_prefixes=(_arg0); end

    # Allows the application to perform custom error reporting, by overriding
    # this method.
    #
    # @param exception [Exception] An exception that occurred while running a command through
    #   {Command.run}.
    # @raise By default re-raises the specified exception.
    # @return [void]
    def report_error(exception); end

    # @return [Bool] Whether this is the root command class
    def root_command?; end

    # Instantiates the command class matching the parameters through
    # {Command.parse}, validates it through {Command#validate!}, and runs it
    # through {Command#run}.
    #
    # @note The ANSI support is configured before running a command to allow
    #   the same process to run multiple commands with different
    #   settings.  For example a process with ANSI output enabled might
    #   want to programmatically invoke another command with the output
    #   enabled.
    # @param argv [Array, ARGV] A list of parameters. For instance, the standard `ARGV` constant,
    #   which contains the parameters passed to the program.
    # @return [void]
    def run(argv = T.unsafe(nil)); end

    # @return [Array<Class>] A list of all command classes that are nested
    #   under this command.
    def subcommands; end

    # @return [Array<Class>] A list of command classes that are nested under
    #   this command _or_ the subcommands of those command classes in
    #   case the command class should be ignored in command lookup.
    def subcommands_for_command_lookup; end

    # @return [String] A brief description of the command, which is shown
    #   next to the command in the help banner of a parent command.
    def summary; end

    # @return [String] A brief description of the command, which is shown
    #   next to the command in the help banner of a parent command.
    def summary=(_arg0); end

    # @return [String] The version of the command. This value will be printed
    #   by the `--version` flag if used for the root command.
    def version; end

    # @return [String] The version of the command. This value will be printed
    #   by the `--version` flag if used for the root command.
    def version=(_arg0); end

    private

    # Adds a new option for the current command.
    #
    # This method can be used in conjunction with overriding `options`.
    #
    # @example
    #
    #   option '--help', 'Print help banner '
    # @return [void]
    def option(name, description); end
  end
end

CLAide::Command::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Array)
CLAide::Command::DEFAULT_ROOT_OPTIONS = T.let(T.unsafe(nil), Array)

# This module is used by Command::PluginsHelper to download the Gem
# Specification data, check if a Gem is installed, and provide info
# on all versions of a Gem.
module CLAide::Command::GemHelper
  class << self
    # Getter for GemIndexCache
    #
    # @return [GemIndexCache] a new or memoized GemIndexCache
    def cache; end

    # Colorize an Array of version strings so versions that are installed
    # are green and uninstalled versions are yellow.
    #
    # @param versions [Array] sorted array of Gem::NameTuples representing all versions of
    #   a plugin gem.
    # @return [Array] An array of strings, each one being the version
    #   string of the same plugin
    def colorize_versions(versions); end

    # Instantiate a cache and download the spec index if it has
    # not already been done.
    def download_and_cache_specs; end

    # Tells if a gem is installed
    #
    # @param gem_name [String] The name of the plugin gem to test
    # @param version_string [String] An optional version string, used to check if a specific
    #   version of a gem is installed
    # @return [Bool] true if the gem is installed, false otherwise.
    def gem_installed?(gem_name, version_string = T.unsafe(nil)); end

    # Get the version of a gem that is installed locally. If more than
    # one version is installed, this returns the first version found,
    # which MAY not be the highest/newest version.
    #
    # @return [String] The version of the gem that is installed,
    #   or nil if it is not installed.
    def installed_version(gem_name); end

    # Create a string containing all versions of a plugin,
    # colored to indicate if a specific version is installed
    # locally.
    #
    # @param plugin_name [String] The name of the plugin gem
    # @param index_cache [GemIndexCache] Optional index cache can be passed in, otherwise
    #   the module instance is used.
    # @return [String] a string containing a comma separated
    #   concatenation of all versions of a plugin
    #   that were found on rubygems.org
    def versions_string(plugin_name, index_cache = T.unsafe(nil)); end
  end
end

# This class is used by Command::GemsHelper to download the Gem
# Specification index from rubygems.org and provide info about
# the index.
class CLAide::Command::GemIndexCache
  # A memoized hash of all the rubygem specs. If it is nil, the specs will
  # be downloaded, which will take a few seconds to download.
  # Alias to make the initial caching process more readable.
  #
  # @return [Hash] The hash of all rubygems
  def download_and_cache_specs; end

  # A memoized hash of all the rubygem specs. If it is nil, the specs will
  # be downloaded, which will take a few seconds to download.
  #
  # @return [Hash] The hash of all rubygems
  def specs; end

  # Get an Array of Gem::NameTuple objects that match a given
  # spec name.
  #
  # @param name [String] The name of the gem to match on (e.g. 'cocoapods-try')
  # @return [Array] Array of Gem::NameTuple that match the name
  def specs_with_name(name); end

  private

  # Force the rubygem spec index file
  #
  # @return [Hash] The hash of all rubygems
  def download_specs; end

  # Flatten the dictionary returned from Gem::SpecFetcher
  # to a simple array.
  #
  # @param results [Hash] the hash returned from the call to
  #   Gem::SpecFetcher.available_specs()
  # @return [Array] Array of all spec results
  def flatten_fetcher_results(results); end
end

# The claide plugins command.
class CLAide::Command::Plugins < ::CLAide::Command; end

# The create subcommand. Used to create a new plugin using either the
# default template (CocoaPods/cocoapods-plugin-template) or a custom
# template
class CLAide::Command::Plugins::Create < ::CLAide::Command::Plugins
  # @return [Create] a new instance of Create
  def initialize(argv); end

  def run; end
  def validate!; end

  private

  # Shows a reminder to the plugin author to make a Pull Request
  # in order to update plugins.json once the plugin is released
  def show_reminder; end

  class << self
    def description; end
  end
end

# The list subcommand. Used to list all known plugins
class CLAide::Command::Plugins::List < ::CLAide::Command::Plugins
  def run; end

  class << self
    def description; end
    def options; end
  end
end

# The search subcommand.
# Used to search a plugin in the list of known plugins,
# searching into the name, author description fields
class CLAide::Command::Plugins::Search < ::CLAide::Command::Plugins
  # @return [Search] a new instance of Search
  def initialize(argv); end

  def run; end
  def validate!; end

  class << self
    def options; end
  end
end

# This module is used by Command::Plugins::List
# and Command::Plugins::Search to download and parse
# the JSON describing the plugins list and manipulate it
module CLAide::Command::PluginsHelper
  class << self
    # Force-download the JSON
    #
    # @return [Hash] The hash representing the JSON with all known plugins
    def download_json; end

    # The list of all known plugins, according to
    # the JSON hosted on github's cocoapods-plugins
    #
    # @return [Array] all known plugins, as listed in the downloaded JSON
    def known_plugins; end

    # Filter plugins to return only matching ones
    #
    # @param query [String] A query string that corresponds to a valid RegExp pattern.
    # @param full_text_search [Bool] false only searches in the plugin's name.
    #   true searches in the plugin's name, author and description.
    # @return [Array] all plugins matching the query
    def matching_plugins(query, full_text_search); end

    # Parse the given JSON data, handling parsing errors if any
    #
    # @param json_str [String] The string representation of the JSON to parse
    def parse_json(json_str); end

    def plugin_prefix; end

    # Format the title line to print the plugin info with print_plugin
    # coloring it according to whether the plugin is installed or not
    #
    # @param plugin [Hash] The hash describing the plugin
    # @return [String] The formatted and colored title
    def plugin_title(plugin); end

    def plugins_raw_url; end

    # Display information about a plugin
    #
    # @param plugin [Hash] The hash describing the plugin
    # @param verbose [Bool] If true, will also print the author of the plugins.
    #   Defaults to false.
    def print_plugin(plugin, verbose = T.unsafe(nil)); end

    # Smaller helper to print out the verbose details
    # for a plugin.
    #
    # @param plugin [Hash] The hash describing the plugin
    # @param ljust [Integer] The left justification that is passed into UI.labeled
    def print_verbose_plugin(plugin, ljust); end
  end
end

# Module which provides support for running executables.
#
# In a class it can be used as:
#
#     extend Executable
#     executable :git
#
# This will create two methods `git` and `git!` both accept a command but
# the latter will raise on non successful executions. The methods return the
# output of the command.
module CLAide::Executable
  # Creates the methods for the executable with the given name.
  #
  # @param name [Symbol] the name of the executable.
  # @return [void]
  def executable(name); end

  class << self
    # Executes the given command. Displays output if in verbose mode.
    #
    # @param bin [String] The binary to use.
    # @param command [Array<#to_s>] The command to send to the binary.
    # @param raise_on_failure [Bool] Whether it should raise if the command fails.
    # @raise If the executable could not be located.
    # @raise If the command fails and the `raise_on_failure` is set to true.
    # @return [String] the output of the command (STDOUT and STDERR).
    # @todo Find a way to display the live output of the commands.
    def execute_command(exe, command, raise_on_failure); end
  end
end

# Helper class that allows to write to an {IO} instance taking into account
# the UI indentation level.
class CLAide::Executable::Indenter < ::Array
  # @param io [IO] @see io
  # @return [Indenter] a new instance of Indenter
  def initialize(io = T.unsafe(nil)); end

  # Stores a portion of the output and prints it to the {IO} instance.
  #
  # @param value [String] the output to print.
  # @return [void]
  def <<(value); end

  # @return [Fixnum] The indentation level of the UI.
  def indent; end

  # @return [Fixnum] The indentation level of the UI.
  def indent=(_arg0); end

  # @return [IO] the {IO} to which the output should be printed.
  def io; end

  # @return [IO] the {IO} to which the output should be printed.
  def io=(_arg0); end
end

# Indicates a user error.
class CLAide::Informative < ::CLAide::PlainInformative; end

# Indicates a runtime error **not** caused by a bug.
class CLAide::PlainInformative < ::StandardError; end

module CLAide::Plugins
  class << self
    # Returns the value of attribute config.
    def config; end

    # Sets the attribute config
    #
    # @param value the value to set the attribute config to.
    def config=(_arg0); end
  end
end

class CLAide::Plugins::Configuration
  # @return [Configuration] a new instance of Configuration
  def initialize(name = T.unsafe(nil), plugin_prefix = T.unsafe(nil), plugin_list_url = T.unsafe(nil), plugin_template_url = T.unsafe(nil)); end

  # name of the plugin
  def name; end

  # name of the plugin
  def name=(_arg0); end

  # url for JSON file that holds list of plugins to show when searching
  def plugin_list_url; end

  # url for JSON file that holds list of plugins to show when searching
  def plugin_list_url=(_arg0); end

  # prefix to use when searching for gems to load at runtime
  def plugin_prefix; end

  # prefix to use when searching for gems to load at runtime
  def plugin_prefix=(_arg0); end

  # url for repo that holds template to use when creating a new plugin
  def plugin_template_url; end

  # url for repo that holds template to use when creating a new plugin
  def plugin_template_url=(_arg0); end
end

class CLAide::TemplateRunner
  extend ::CLAide::Executable

  # @return [TemplateRunner] a new instance of TemplateRunner
  def initialize(name, template_url); end

  # Clones the template from the remote in the working directory using
  # the name of the plugin.
  #
  # @return [void]
  def clone_template; end

  # Runs the template configuration utilities.
  #
  # @return [void]
  def configure_template; end

  def git(*command); end
  def git!(*command); end

  # Checks if a template URL is given else returns the Plugins.config URL
  #
  # @return String
  def template_repo_url; end
end

UI = T.let(T.unsafe(nil), Cork::Board)
