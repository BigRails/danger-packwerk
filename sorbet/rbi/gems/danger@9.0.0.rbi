# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `danger` gem.
# Please instead update this file by running `bin/tapioca gem danger`.

# Just a less verbose way of doing the Dangerfile from `danger init`.
module Danger
  class << self
    # @return [String] Latest version of Danger on https://rubygems.org
    def danger_outdated?; end

    # @return [String] The path to the local gem directory
    def gem_path; end
  end
end

# ### CI Setup
#
# Install dependencies and add a danger step to your `appveyor.yml`.
#
# ```yaml
# install:
# - cmd: >-
#     set PATH=C:\Ruby25-x64\bin;%PATH%
#
#     bundle install
# after_test:
# - cmd: >-
#     bundle exec danger
# ```
#
# ### Token Setup
#
# For public repositories, add your plain token to environment variables in `appveyor.yml`.
# Encrypted environment variables will not be decrypted on PR builds.
# see here: https://www.appveyor.com/docs/build-configuration/#secure-variables
#
# ```yaml
# environment:
#   DANGER_GITHUB_API_TOKEN: <YOUR_TOKEN_HERE>
# ```
#
# For private repositories, enter your token in `Settings>Environment>Environment variables>Add variable` and turn on `variable encryption`.
# You will see encrypted variable text in `Settings>Export YAML` so just copy to your `appveyor.yml`.
#
# ```yaml
# environment:
#   DANGER_GITHUB_API_TOKEN:
#     secure: <YOUR_ENCRYPTED_TOKEN_HERE>
# ```
class Danger::AppVeyor < ::Danger::CI
  # @return [AppVeyor] a new instance of AppVeyor
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# Add a script step to your appcenter-post-build.sh:
#
# ```shell
#   #!/usr/bin/env bash
#   bundle install
#   bundle exec danger
# ```
#
# ### Token Setup
#
# Add the `DANGER_GITHUB_API_TOKEN` to your environment variables.
class Danger::Appcenter < ::Danger::CI
  # @return [Appcenter] a new instance of Appcenter
  def initialize(env); end

  def supported_request_sources; end

  class << self
    def owner_for_github(env); end

    # Hopefully it's a temporary workaround (same as in Codeship integration) because App Center
    # doesn't expose PR's ID. There's a future request https://github.com/Microsoft/appcenter/issues/79
    def pr_from_env(env); end

    def repo_identifier_for_github(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# Add a script step:
#
# ```shell
#   #!/usr/bin/env bash
#   bundle install
#   bundle exec danger
# ```
#
# ### Token Setup
#
# Add the `DANGER_GITHUB_API_TOKEN` to your environment variables.
class Danger::AzurePipelines < ::Danger::CI
  # @return [AzurePipelines] a new instance of AzurePipelines
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# Add a Run Script task that executes `danger` (or `bundle exec danger` if you're using Bundler
# to manage your gems) as your as part of your Bamboo plan.
# The minimum supported version is Bamboo 6.9.
#
# ### Token Setup
#
# IMPORTANT: All required Bamboo environment variables will be available
# only if the plan is run as part of a pull request. This can be achieved by selecting:
# Configure plan -> Branches -> Create plan branch: "When pull request is created".
# Otherwise, `bamboo_repository_pr_key` and `bamboo_planRepository_repositoryUrl`
# will not be available.
class Danger::Bamboo < ::Danger::CI
  # @return [Bamboo] a new instance of Bamboo
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

class Danger::BaseMessage
  # @return [BaseMessage] a new instance of BaseMessage
  def initialize(type:, message:, file: T.unsafe(nil), line: T.unsafe(nil)); end

  # compares a and b based entirely on whether one or the other is nil
  # arguments are in the same order as `a <=> b`
  # nil is sorted earlier - so cmp_nils(nil, 1) => -1
  #
  # If neither are nil, rather than returning `a <=> b` which would seem
  # like the obvious shortcut, `nil` is returned.
  # This allows us to distinguish between cmp_nils returning 0 for a
  # comparison of filenames, which means "a comparison on the lines is
  # meaningless - you cannot have a line number for a nil file - so they
  # should be sorted the same", and a <=> b returning 0, which means "the
  # files are the same, so compare on the lines"
  #
  # @return 0, 1, -1, or nil
  def cmp_nils(a, b); end

  def compare_by_file_and_line(other); end

  # @return [Boolean]
  def eql?(other); end

  # Returns the value of attribute file.
  def file; end

  # Sets the attribute file
  #
  # @param value the value to set the attribute file to.
  def file=(_arg0); end

  # @return [Boolean] returns true if is a file or line, false otherwise
  def inline?; end

  # Returns the value of attribute line.
  def line; end

  # Sets the attribute line
  #
  # @param value the value to set the attribute line to.
  def line=(_arg0); end

  # Returns the value of attribute message.
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  def message=(_arg0); end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end
end

# ### CI Setup
#
# Install dependencies and add a danger step to your `bitbucket-pipelines.yml`.
#
# ```yaml
#   script:
#     - bundle exec danger --verbose
# ```
#
# ### Token Setup
#
# Add `DANGER_BITBUCKETCLOUD_USERNAME` and `DANGER_BITBUCKETCLOUD_PASSWORD` to your pipeline repository variable
# or instead using `DANGER_BITBUCKETCLOUD_OAUTH_KEY` and `DANGER_BITBUCKETCLOUD_OAUTH_SECRET`.
#
# You can find them in Settings > Pipelines > Repository Variables
class Danger::BitbucketPipelines < ::Danger::CI
  # @return [BitbucketPipelines] a new instance of BitbucketPipelines
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# Add a script step to your workflow:
#
# ```yml
# - script@1.1.2:
#     inputs:
#    - content: |-
#        bundle install
#        bundle exec danger
# ```
#
# ### Token Setup
#
# Add the `DANGER_GITHUB_API_TOKEN` to your workflow's [Secret App Env Vars](https://blog.bitrise.io/anyone-even-prs-can-have-secrets).
#
# ### bitbucket server and bitrsie
#
# Danger will read the environment variable GIT_REPOSITORY_URL to construct the Bitbucket Server API URL
# finding the project and repo slug in the GIT_REPOSITORY_URL variable. This GIT_REPOSITORY_URL variable
# comes from the App Settings tab for your Bitrsie App. If you are manually setting a repo URL in the
# Git Clone Repo step, you may need to set adjust this propery in the settings tab, maybe even fake it.
# The patterns used are `(%r{\.com/(.*)})` and `(%r{\.com:(.*)})` and .split(/\.git$|$/) to remove ".git" if the URL contains it.
class Danger::Bitrise < ::Danger::CI
  # @return [Bitrise] a new instance of Bitrise
  def initialize(env); end

  def repo_slug_asgiturl(url); end
  def repo_slug_from(url); end
  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# Read how you can setup Danger on the buddybuild blog:
# https://www.buddybuild.com/blog/using-danger-with-buddybuild/
#
# ### Token Setup
#
# Login to buddybuild and select your app. Go to your *App Settings* and
# in the *Build Settings* menu on the left, choose *Environment Variables*.
# http://docs.buddybuild.com/docs/environment-variables
#
# #### GitHub
# Add the `DANGER_GITHUB_API_TOKEN` to your build user's ENV.
#
# #### GitLab
# Add the `DANGER_GITLAB_API_TOKEN` to your build user's ENV.
#
# #### Bitbucket Cloud
# Add the `DANGER_BITBUCKETSERVER_USERNAME`, `DANGER_BITBUCKETSERVER_PASSWORD`
# to your build user's ENV.
#
# #### Bitbucket server
# Add the `DANGER_BITBUCKETSERVER_USERNAME`, `DANGER_BITBUCKETSERVER_PASSWORD`
# and `DANGER_BITBUCKETSERVER_HOST` to your build user's ENV.
#
# ### Running Danger
#
# Once the environment variables are all available, create a custom build step
# to run Danger as part of your build process:
# http://docs.buddybuild.com/docs/custom-prebuild-and-postbuild-steps
class Danger::Buddybuild < ::Danger::CI
  # @return [Buddybuild] a new instance of Buddybuild
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# With BuildKite you run the server yourself, so you will want to run  it as a part of your build process.
# It is common to have build steps, so we would recommend adding this to your scrip:
#
#  ```shell
#   echo "--- Running Danger"
#   bundle exec danger
#  ```
#
# ### Token Setup
#
# #### GitHub
#
# As this is self-hosted, you will need to add the `DANGER_GITHUB_API_TOKEN` to your build user's ENV. The alternative
# is to pass in the token as a prefix to the command `DANGER_GITHUB_API_TOKEN="123" bundle exec danger`.
#
# #### GitLab
#
# As this is self-hosted, you will need to add the `DANGER_GITLAB_API_TOKEN` to your build user's ENV. The alternative
# is to pass in the token as a prefix to the command `DANGER_GITLAB_API_TOKEN="123" bundle exec danger`.
class Danger::Buildkite < ::Danger::CI
  # @return [Buildkite] a new instance of Buildkite
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# "abstract" CI class
class Danger::CI
  # @return [CI] a new instance of CI
  def initialize(_env); end

  # Returns the value of attribute pull_request_id.
  def pull_request_id; end

  # Sets the attribute pull_request_id
  #
  # @param value the value to set the attribute pull_request_id to.
  def pull_request_id=(_arg0); end

  # Returns the value of attribute repo_slug.
  def repo_slug; end

  # Sets the attribute repo_slug
  #
  # @param value the value to set the attribute repo_slug to.
  def repo_slug=(_arg0); end

  # Returns the value of attribute repo_url.
  def repo_url; end

  # Sets the attribute repo_url
  #
  # @param value the value to set the attribute repo_url to.
  def repo_url=(_arg0); end

  # Returns the value of attribute supported_request_sources.
  def supported_request_sources; end

  # Sets the attribute supported_request_sources
  #
  # @param value the value to set the attribute supported_request_sources to.
  def supported_request_sources=(_arg0); end

  # @return [Boolean]
  def supports?(request_source); end

  class << self
    def available_ci_sources; end

    # @private
    def inherited(child_class); end

    # @return [Boolean]
    def validates_as_ci?(_env); end

    # @return [Boolean]
    def validates_as_pr?(_env); end
  end
end

class Danger::CIDocs < ::Danger::Systems
  def run; end
end

class Danger::CircleAPI
  def client; end

  # Make the API call, and parse the JSON
  def fetch_build(repo_slug, build_number, token); end

  # Ask the API if the commit is inside a PR
  def fetch_pull_request_url(repo_slug, build_number, token); end

  # Determine if there's a PR attached to this commit,
  # and return a bool
  #
  # @return [Boolean]
  def pull_request?(env); end

  # Determine if there's a PR attached to this commit,
  # and return the url if so
  def pull_request_url(env); end
end

# ### CI Setup
#
# For setting up CircleCI, we recommend turning on "Only build pull requests" in "Advanced Settings." Without this enabled,
# it's trickier for Danger to determine whether you're in a pull request or not, as the environment metadata
# isn't as reliable.
#
# A common scenario is when CircleCI begins building a commit before the commit becomes associated with a PR
# (e.g. a developer pushes their branch to the remote repo for the first time. CircleCI spins up and begins building.
# Moments later the developer creates a PR on GitHub. Since the build process started before the PR existed,
# Danger won't be able to use the Circle-provided environment variables to retrieve PR metadata.)
#
# With "Only build pull requests" enabled, you can add `bundle exec danger` to your `config.yml` (Circle 2.0).
#
# e.g.
#
#  ```yaml
#  - run: bundle exec danger --verbose
#  ```
#
# And that should be it!
#
# ### Token Setup
#
# If "Only build pull requests" can't be enabled for your project, Danger _can_ still work by relying on CircleCI's API
# to retrieve PR metadata, which will require an API token.
#
# 1. Go to your project > Settings > API Permissions. Create a token with scope "view-builds" and a label like "DANGER_CIRCLE_CI_API_TOKEN".
# 2. Settings > Environement Variables. Add the token as a CircleCI environment variable, which exposes it to the Danger process.
#
# There is no difference here for OSS vs Closed, both scenarios will need this environment variable.
#
# With these pieces in place, Danger should be able to work as expected.
class Danger::CircleCI < ::Danger::CI
  # @return [CircleCI] a new instance of CircleCI
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # Side note: CircleCI is complicated. The env vars for PRs are not guaranteed to exist
    # if the build was triggered from a commit, to look at examples of the different types
    # of CI states, see this repo: https://github.com/orta/show_circle_env
    #
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
# You need to edit your `.cirrus.yml` to include `bundler exec danger`.
#
# Adding this to your `.cirrus.yml` allows Danger to fail your build, both on the Cirrus CI website and within your Pull Request.
# With that set up, you can edit your task to add `bundler exec danger` in any script instruction.
class Danger::Cirrus < ::Danger::CI
  # @return [Cirrus] a new instance of Cirrus
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# In CodeBuild, make sure to correctly forward CODEBUILD_BUILD_ID, CODEBUILD_SOURCE_VERSION, CODEBUILD_SOURCE_REPO_URL and DANGER_GITHUB_API_TOKEN.
# In CodeBuild with batch builds, make sure to correctly forward CODEBUILD_BUILD_ID, CODEBUILD_WEBHOOK_TRIGGER, CODEBUILD_SOURCE_REPO_URL, CODEBUILD_BATCH_BUILD_IDENTIFIER and DANGER_GITHUB_API_TOKEN.
#
# ### Token Setup
#
# Add your `DANGER_GITHUB_API_TOKEN` to your project. Edit -> Environment -> Additional configuration -> Create a parameter
class Danger::CodeBuild < ::Danger::CI
  # @return [CodeBuild] a new instance of CodeBuild
  def initialize(env); end

  def supported_request_sources; end

  class << self
    def extract_pr_url(env); end
    def extract_repo_slug(env); end
    def extract_repo_url(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
#  To set up Danger on Codefresh, create a freestyle step in your Codefresh yaml configuration:
#
#  ```yml
#  Danger:
#    title: Run Danger
#    image: alpine/bundle
#    working_directory: ${{main_clone}}
#    commands:
#      - bundle install --deployment
#      - bundle exec danger --verbose
#  ```
#
#  Don't forget to add the `DANGER_GITHUB_API_TOKEN` variable to your pipeline settings so that Danger can properly post comments to your pull request.
class Danger::Codefresh < ::Danger::CI
  # @return [Codefresh] a new instance of Codefresh
  def initialize(env); end

  def supported_request_sources; end

  class << self
    def slug_from(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# Add a script step to your workflow:
#
# ```
# - name: Running Danger
#   script: |
#     bundle install
#     bundle exec danger
# ```
#
# ### Token Setup
#
# Add the following environment variables to your workflow's environment configuration.
# https://docs.codemagic.io/getting-started/yaml/
#
# #### GitHub
# Add the `DANGER_GITHUB_API_TOKEN` to your build user's ENV.
#
# #### GitLab
# Add the `DANGER_GITLAB_API_TOKEN` to your build user's ENV.
#
# #### Bitbucket Cloud
# Add the `DANGER_BITBUCKETSERVER_USERNAME`, `DANGER_BITBUCKETSERVER_PASSWORD`
# to your build user's ENV.
#
# #### Bitbucket server
# Add the `DANGER_BITBUCKETSERVER_USERNAME`, `DANGER_BITBUCKETSERVER_PASSWORD`
# and `DANGER_BITBUCKETSERVER_HOST` to your build user's ENV.
class Danger::Codemagic < ::Danger::CI
  # @return [Codemagic] a new instance of Codemagic
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# In Codeship, go to your "Project Settings", then add `bundle exec danger` as a test step inside
# one of your pipelines.
#
# ### Token Setup
#
# Add your `DANGER_GITHUB_API_TOKEN` to "Environment" section in "Project Settings".
class Danger::Codeship < ::Danger::CI
  # @return [Codeship] a new instance of Codeship
  def initialize(env); end

  def supported_request_sources; end

  class << self
    def owner_for_github(env); end

    # this is fairly hacky, see https://github.com/danger/danger/pull/892#issuecomment-329030616 for why
    def pr_from_env(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

class Danger::Comment
  # @return [Comment] a new instance of Comment
  def initialize(id, body, inline = T.unsafe(nil)); end

  # Returns the value of attribute body.
  def body; end

  # @return [Boolean]
  def generated_by_danger?(danger_id); end

  # Returns the value of attribute id.
  def id; end

  # @return [Boolean]
  def inline?; end

  class << self
    def from_github(comment); end
    def from_gitlab(comment); end
  end
end

class Danger::Commits
  # @return [Commits] a new instance of Commits
  def initialize(base_head); end

  def base; end
  def head; end

  private

  # Returns the value of attribute base_head.
  def base_head; end
end

# ### CI Setup
#
# With Concourse, you run the docker images yourself, so you will want to add `yarn danger ci` within one of your build jobs.
#
#   ```shell
#    build:
#      image: golang
#        commands:
#          - ...
#          - yarn danger ci
#   ```
#
# ### Environment Variable Setup
#
# As this is self-hosted, you will need to add the `CONCOURSE` environment variable `export CONCOURSE=true` to your build environment,
# as well as setting environment variables for `PULL_REQUEST_ID` and `REPO_SLUG`. Assuming you are using the github pull request resource
# https://github.com/jtarchie/github-pullrequest-resource the id of the PR can be accessed from `git config --get pullrequest.id`.
#
# ### Token Setup
#
# Once again as this is self-hosted, you will need to add `DANGER_GITHUB_API_TOKEN` environment variable to the build environment.
# The suggested method of storing the token is within the vault - https://concourse-ci.org/creds.html
class Danger::Concourse < ::Danger::CI
  # @return [Concourse] a new instance of Concourse
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

Danger::DESCRIPTION = T.let(T.unsafe(nil), String)

# Wraps an exception raised by a DSL file in order to show to the user the
# contents of the line that raised the exception.
class Danger::DSLError < ::StandardError
  # @param backtrace [Exception] @see backtrace
  # @param dsl_path [String] @see dsl_path
  # @return [DSLError] a new instance of DSLError
  def initialize(description, dsl_path, backtrace, contents = T.unsafe(nil)); end

  # @return [Exception] the backtrace of the exception raised by the
  #   evaluation of the dsl file.
  def backtrace; end

  # @return [String] the contents of the DSL that cause the exception to
  #   be raised.
  def contents; end

  # @return [String] the description that should be presented to the user.
  def description; end

  # @return [String] the path of the dsl file that raised the exception.
  def dsl_path; end

  # The message of the exception reports the content of podspec for the
  # line that generated the original exception.
  #
  # @example Output
  #
  #   Invalid podspec at `RestKit.podspec` - undefined method
  #   `exclude_header_search_paths=' for #<Pod::Specification for
  #   `RestKit/Network (0.9.3)`>
  #
  #   from spec-repos/master/RestKit/0.9.3/RestKit.podspec:36
  #   -------------------------------------------
  #   # because it would break: #import <CoreData/CoreData.h>
  #   >      ns.exclude_header_search_paths = 'Code/RestKit.h'
  #   end
  #   -------------------------------------------
  # @return [String] the message of the exception.
  def message; end

  def to_markdown; end

  private

  def parse; end
  def parse_line_number_from_description; end
  def upgrade_message(latest_version); end
end

class Danger::Dangerfile
  include ::Danger::Dangerfile::DSL

  # cork_board not being set comes from plugins #585
  #
  # @return [Dangerfile] a new instance of Dangerfile
  def initialize(env_manager, cork_board = T.unsafe(nil)); end

  def core_dsl_attributes; end

  # @return [Pathname] the path where the Dangerfile was loaded from. It is nil
  #   if the Dangerfile was generated programmatically.
  def defined_in_file; end

  # @return [Pathname] the path where the Dangerfile was loaded from. It is nil
  #   if the Dangerfile was generated programmatically.
  def defined_in_file=(_arg0); end

  # Returns the value of attribute env.
  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  def env=(_arg0); end

  def external_dsl_attributes; end
  def fail(*args, **kargs, &blk); end

  # @return [Boolean]
  def failed?; end

  # Iterate through available plugin classes and initialize them with
  # a reference to this Dangerfile
  def init_plugins; end

  def method_missing(method_sym, *arguments, **keyword_arguments, &_block); end
  def method_values_for_plugin_hashes(plugin_hashes); end

  # Parses the file at a path, optionally takes the content of the file for DI
  def parse(path, contents = T.unsafe(nil)); end

  # Returns the value of attribute plugins.
  def plugins; end

  # Sets the attribute plugins
  #
  # @param value the value to set the attribute plugins to.
  def plugins=(_arg0); end

  def post_results(danger_id, new_comment, remove_previous_comments); end

  # Iterates through the DSL's attributes, and table's the output
  def print_known_info; end

  def print_results; end

  # Iterate through available plugin classes and initialize them with
  # a reference to this Dangerfile
  def refresh_plugins; end

  def run(base_branch, head_branch, dangerfile_path, danger_id, new_comment, remove_previous_comments, report_results = T.unsafe(nil)); end
  def setup_for_running(base_branch, head_branch); end

  # @return [String] a string useful to represent the Dangerfile in a message
  #   presented to the user.
  def to_s; end

  # Returns the value of attribute ui.
  def ui; end

  # Sets the attribute ui
  #
  # @param value the value to set the attribute ui to.
  def ui=(_arg0); end

  # Returns the value of attribute verbose.
  def verbose; end

  # Sets the attribute verbose
  #
  # @param value the value to set the attribute verbose to.
  def verbose=(_arg0); end

  # Both of these methods exist on all objects
  # http://ruby-doc.org/core-2.2.3/Kernel.html#method-i-warn
  # http://ruby-doc.org/core-2.2.3/Kernel.html#method-i-fail
  # However, as we're using using them in the DSL, they won't
  # get method_missing called correctly without overriding them.
  def warn(*args, **kargs, &blk); end

  private

  def eval_file(contents, path); end
  def post_exception(ex, danger_id, new_comment); end
  def print_list(title, rows); end
  def wrap_text(text, width = T.unsafe(nil)); end

  class << self
    # These are the classes that are allowed to also use method_missing
    # in order to provide broader plugin support
    def core_plugin_classes; end

    # The ones that everything would break without
    def essential_plugin_classes; end
  end
end

# Anything inside this module is considered public API, and in the future
# documentation will be generated from it via rdoc.
module Danger::Dangerfile::DSL
  def initialize; end

  # Provides access to the raw Travis/Circle/Buildkite/GitHub objects, which
  # you can use to pull out extra bits of information. _Warning_
  # the interfaces of these objects is **not** considered a part of the Dangerfile public
  # API, and is viable to change occasionally on the whims of developers.
  #
  # @return [EnvironmentManager]
  def env; end

  private

  def load_default_plugins; end
end

# Handles interacting with Bitbucket Cloud inside a Dangerfile. Provides a few functions which wrap `pr_json` and also
# through a few standard functions to simplify your code.
#
# @example Warn when a PR is classed as work in progress
#
#   warn "PR is classed as Work in Progress" if bitbucket_cloud.pr_title.include? "[WIP]"
# @example Declare a PR to be simple to avoid specific Danger rules
#
#   declared_trivial = (bitbucket_cloud.pr_title + bitbucket_cloud.pr_body).include?("#trivial")
# @example Ensure that labels have been used on the PR
#
#   failure "Please add labels to this PR" if bitbucket_cloud.pr_labels.empty?
# @example Ensure there is a summary for a PR
#
#   failure "Please provide a summary in the Pull Request description" if bitbucket_cloud.pr_body.length < 5
# @example Only accept PRs to the develop branch
#
#   failure "Please re-submit this PR to develop, we may have already fixed your issue." if bitbucket_cloud.branch_for_base != "develop"
# @example Highlight when a celebrity makes a pull request
#
#   message "Welcome, Danger." if bitbucket_cloud.pr_author == "dangermcshane"
# @example Ensure that all PRs have an assignee
#
#   warn "This PR does not have any assignees yet." if bitbucket_cloud.pr_json[:reviewers].length == 0
# @example Send a message with links to a collection of specific files
#
#   if git.modified_files.include? "config/*.js"
#   config_files = git.modified_files.select { |path| path.include? "config/" }
#   message "This PR changes #{ bitbucket_cloud.html_link(config_files) }"
#   end
# @example Highlight with a clickable link if a Package.json is changed
#
#   warn "#{bitbucket_cloud.html_link("Package.json")} was edited." if git.modified_files.include? "Package.json"
# @see danger/danger
class Danger::DangerfileBitbucketCloudPlugin < ::Danger::Plugin
  # @return [DangerfileBitbucketCloudPlugin] a new instance of DangerfileBitbucketCloudPlugin
  def initialize(dangerfile); end

  # The base commit to which the PR is going to be merged as a parent.
  #
  # @return [String]
  def base_commit; end

  # The branch to which the PR is going to be merged into.
  #
  # @return [String]
  def branch_for_base; end

  # The branch to which the PR is going to be merged from.
  #
  # @return [String]
  def branch_for_head; end

  # The head commit to which the PR is requesting to be merged from.
  #
  # @return [String]
  def head_commit; end

  # The username of the author of the Pull Request.
  #
  # @return [String]
  def pr_author; end

  # The body text of the Pull Request.
  #
  # @return [String]
  def pr_body; end

  # The body text of the Pull Request.
  #
  # @return [String]
  def pr_description; end

  # The hash that represents the PR's JSON. For an example of what this looks like
  # see the [Danger Fixture'd one](https://raw.githubusercontent.com/danger/danger/master/spec/fixtures/bitbucket_cloud_api/pr_response.json).
  #
  # @return [Hash]
  def pr_json; end

  # A href that represents the current PR
  #
  # @return [String]
  def pr_link; end

  # The title of the Pull Request.
  #
  # @return [String]
  def pr_title; end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end

    # So that this init can fail.
    def new(dangerfile); end
  end
end

# Handles interacting with Bitbucket Server inside a Dangerfile. Provides a few functions which wrap `pr_json` and also
# through a few standard functions to simplify your code.
#
# @example Warn when a PR is classed as work in progress
#
#   warn "PR is classed as Work in Progress" if bitbucket_server.pr_title.include? "[WIP]"
# @example Declare a PR to be simple to avoid specific Danger rules
#
#   declared_trivial = (bitbucket_server.pr_title + bitbucket_server.pr_body).include?("#trivial")
# @example Ensure that labels have been used on the PR
#
#   failure "Please add labels to this PR" if bitbucket_server.pr_labels.empty?
# @example Ensure there is a summary for a PR
#
#   failure "Please provide a summary in the Pull Request description" if bitbucket_server.pr_body.length < 5
# @example Only accept PRs to the develop branch
#
#   failure "Please re-submit this PR to develop, we may have already fixed your issue." if bitbucket_server.branch_for_base != "develop"
# @example Highlight when a celebrity makes a pull request
#
#   message "Welcome, Danger." if bitbucket_server.pr_author == "dangermcshane"
# @example Ensure that all PRs have an assignee
#
#   warn "This PR does not have any assignees yet." if bitbucket_server.pr_json[:reviewers].length == 0
# @example Send a message with links to a collection of specific files
#
#   if git.modified_files.include? "config/*.js"
#   config_files = git.modified_files.select { |path| path.include? "config/" }
#   message "This PR changes #{ bitbucket_server.html_link(config_files) }"
#   end
# @example Highlight with a clickable link if a Package.json is changed
#
#   warn "#{bitbucket_server.html_link("Package.json")} was edited." if git.modified_files.include? "Package.json"
# @see danger/danger
class Danger::DangerfileBitbucketServerPlugin < ::Danger::Plugin
  # @return [DangerfileBitbucketServerPlugin] a new instance of DangerfileBitbucketServerPlugin
  def initialize(dangerfile); end

  # The base commit to which the PR is going to be merged as a parent.
  #
  # @return [String]
  def base_commit; end

  # The branch to which the PR is going to be merged into.
  #
  # @return [String]
  def branch_for_base; end

  # The branch to which the PR is going to be merged from.
  #
  # @return [String]
  def branch_for_head; end

  # The head commit to which the PR is requesting to be merged from.
  #
  # @return [String]
  def head_commit; end

  # Returns a list of Markdown links for a file, or files in the head repository.
  # It returns a string of multiple anchors if passed an array.
  #
  # @note Atlassian [disabled inline HTML support](https://jira.atlassian.com/browse/BSERV-7147).
  #   This method method left for backward compatibility.
  # @param paths [String or Array<String>] A list of strings to convert to github anchors
  # @param full_path [Bool] Shows the full path as the link's text, defaults to `true`.
  # @return [String]
  def html_link(paths, full_path: T.unsafe(nil)); end

  # Returns a list of Markdown links for a file, or files in the head repository.
  # It returns a string of multiple links if passed an array.
  #
  # @param paths [String or Array<String>] A list of strings to convert to Markdown links
  # @param full_path [Bool] Shows the full path as the link's text, defaults to `true`.
  # @return [String]
  def markdown_link(paths, full_path: T.unsafe(nil)); end

  # The username of the author of the Pull Request.
  #
  # @return [String]
  def pr_author; end

  # The body text of the Pull Request.
  #
  # @return [String]
  def pr_body; end

  # The body text of the Pull Request.
  #
  # @return [String]
  def pr_description; end

  # The hash that represents the PR's JSON. For an example of what this looks like
  # see the [Danger Fixture'd one](https://raw.githubusercontent.com/danger/danger/master/spec/fixtures/bitbucket_server_api/pr_response.json).
  #
  # @return [Hash]
  def pr_json; end

  # A href that represents the current PR
  #
  # @return [String]
  def pr_link; end

  # The title of the Pull Request.
  #
  # @return [String]
  def pr_title; end

  # Updates the PR with build status and build server job link.
  #
  # @param status [String] SUCCESSFUL, FAILED and INPROGRESS
  # @param build_job_link [String] Build server job link
  # @param description [String] Build status description
  # @return [String]
  def update_pr_build_status(status, build_job_link, description); end

  private

  def create_link(paths, full_path); end
  def create_markdown_link(href, text); end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end

    # So that this init can fail.
    def new(dangerfile); end
  end
end

class Danger::DangerfileCommand < ::Danger::Runner
  class << self
    def options; end
  end
end

# A way to interact with Danger herself. Offering APIs to import plugins,
# and Dangerfiles from multiple sources.
#
# @example Import a plugin available over HTTP
#
#   device_grid = "https://raw.githubusercontent.com/fastlane/fastlane/master/danger-device_grid/lib/device_grid/plugin.rb"
#   danger.import_plugin(device_grid)
# @example Import from a local file reference
#
#   danger.import_plugin("danger/plugins/watch_plugin.rb")
# @example Import all files inside a folder
#
#   danger.import_plugin("danger/plugins/*.rb")
# @example Run a Dangerfile from inside a sub-folder
#
#   danger.import_dangerfile(path: "path/to/Dangerfile")
# @example Run a Dangerfile from inside a gem
#
#   danger.import_dangerfile(gem: "ruby-grape-danger")
# @example Run a Dangerfile from inside a repo
#
#   danger.import_dangerfile(gitlab_project_id: 1345)
# @example Run a Dangerfile from inside a repo branch and path
#
#   danger.import_dangerfile(github: "ruby-grape/danger", branch: "custom", path: "path/to/Dangerfile")
# @example Import a plugin available over HTTP
#
#   custom_url = "https://custom.bitbucket.com/project-name/Dangerfile?raw"
#   danger.import_dangerfile(url: custom_url)
# @see danger/danger
class Danger::DangerfileDangerPlugin < ::Danger::Plugin
  # Import a Dangerfile.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [void]
  def import_dangerfile(opts); end

  # Download a local or remote plugin and make it usable inside the Dangerfile.
  #
  # @param path_or_url [String] a local path or a https URL to the Ruby file to import
  #   a danger plugin from.
  # @return [void]
  def import_plugin(path_or_url); end

  # Returns the name of the current SCM Provider being used.
  #
  # @return [Symbol] The name of the SCM Provider used for the active repository.
  def scm_provider; end

  private

  # Download a local or remote plugin or Dangerfile.
  # This method will not import the file for you, use plugin.import instead
  #
  # @param path_or_url [String] a local path or a https URL to the Ruby file to import
  #   a danger plugin from.
  # @return [String] The path to the downloaded Ruby file
  def download(path_or_url); end

  # Read and execute a Dangerfile from a gem.
  #
  # @param name [String] The name of the gem that contains a Dangerfile.
  # @return [void]
  def import_dangerfile_from_gem(name); end

  # Download and execute a remote Dangerfile.
  #
  # @param slug [String] A slug that represents the repo where the Dangerfile is.
  # @param branch [String] A branch from repo where the Dangerfile is.
  # @param path [String] The path at the repo where Dangerfile is.
  # @return [void]
  def import_dangerfile_from_github(slug, branch = T.unsafe(nil), path = T.unsafe(nil)); end

  # Download and execute a remote Dangerfile.
  #
  # @param slug_or_project_id [Int] The slug or id of the repo where the Dangerfile is.
  # @param branch [String] A branch from repo where the Dangerfile is.
  # @param path [String] The path at the repo where Dangerfile is.
  # @return [void]
  def import_dangerfile_from_gitlab(slug_or_project_id, branch = T.unsafe(nil), path = T.unsafe(nil)); end

  # Read and execute a local Dangerfile.
  #
  # @param path [String] A path to a Dangerfile.
  # @return [void]
  def import_dangerfile_from_path(path); end

  # Download and execute a remote Dangerfile.
  #
  # @param url [String] A https url where the Dangerfile is.
  # @return [void]
  def import_dangerfile_from_url(url); end

  # Import one or more local plugins.
  #
  # @param path [String] The path to the file to import
  #   Can also be a pattern (./**/*plugin.rb)
  # @return [void]
  def import_local(path); end

  # Download a remote plugin and use it locally.
  #
  # @param url [String] https URL to the Ruby file to use
  # @return [void]
  def import_url(url); end

  # Raises an error when the given block does not register a plugin.
  def validate_file_contains_plugin!(file); end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end
  end
end

class Danger::DangerfileGem < ::Danger::DangerfileCommand
  # @return [DangerfileGem] a new instance of DangerfileGem
  def initialize(argv); end

  def run; end
  def validate!; end

  class << self
    def description; end
  end
end

class Danger::DangerfileGenerator
  class << self
    # returns the string for a Dangerfile based on a folder's contents'
    def create_dangerfile(_path, _ui); end
  end
end

# Handles interacting with GitHub inside a Dangerfile. Provides a few functions which wrap `pr_json` and also
# through a few standard functions to simplify your code.
#
# @example Warn when a PR is classed as work in progress
#
#   warn "PR is classed as Work in Progress" if github.pr_title.include? "[WIP]"
# @example Declare a PR to be simple to avoid specific Danger rules
#
#   declared_trivial = (github.pr_title + github.pr_body).include?("#trivial")
# @example Ensure that labels have been used on the PR
#
#   failure "Please add labels to this PR" if github.pr_labels.empty?
# @example Check if a user is in a specific GitHub org, and message them if so
#
#   unless github.api.organization_member?('danger', github.pr_author)
#   message "@#{github.pr_author} is not a contributor yet, would you like to join the Danger org?"
#   end
# @example Ensure there is a summary for a PR
#
#   failure "Please provide a summary in the Pull Request description" if github.pr_body.length < 5
# @example Only accept PRs to the develop branch
#
#   failure "Please re-submit this PR to develop, we may have already fixed your issue." if github.branch_for_base != "develop"
# @example Note when PRs don't reference a milestone, which goes away when it does
#
#   has_milestone = github.pr_json["milestone"] != nil
#   warn("This PR does not refer to an existing milestone", sticky: false) unless has_milestone
# @example Note when a PR cannot be manually merged, which goes away when you can
#
#   can_merge = github.pr_json["mergeable"]
#   warn("This PR cannot be merged yet.", sticky: false) unless can_merge
# @example Highlight when a celebrity makes a pull request
#
#   message "Welcome, Danger." if github.pr_author == "dangermcshane"
# @example Ensure that all PRs have an assignee
#
#   warn "This PR does not have any assignees yet." unless github.pr_json["assignee"]
# @example Send a message with links to a collection of specific files
#
#   if git.modified_files.include? "config/*.js"
#   config_files = git.modified_files.select { |path| path.include? "config/" }
#   message "This PR changes #{ github.html_link(config_files) }"
#   end
# @example Highlight with a clickable link if a Package.json is changed
#
#   warn "#{github.html_link("Package.json")} was edited." if git.modified_files.include? "Package.json"
# @example Note an issue with a particular line on a file using the #L[num] syntax, e.g. `#L23`
#
#   linter_json = `my_linter lint "file"`
#   results = JSON.parse linter_json
#   unless results.empty?
#   file, line, warning = result.first
#   warn "#{github.html_link("#{file}#L#{line}")} has linter issue: #{warning}."
#   end
# @see danger/danger
class Danger::DangerfileGitHubPlugin < ::Danger::Plugin
  # @return [DangerfileGitHubPlugin] a new instance of DangerfileGitHubPlugin
  def initialize(dangerfile); end

  # Provides access to the GitHub API client used inside Danger. Making
  # it easy to use the GitHub API inside a Dangerfile.
  #
  # @return [Octokit::Client]
  def api; end

  # The base commit to which the PR is going to be merged as a parent.
  #
  # @return [String]
  def base_commit; end

  # The branch to which the PR is going to be merged into.
  #
  # @return [String]
  def branch_for_base; end

  # The branch to which the PR is going to be merged from.
  #
  # @return [String]
  def branch_for_head; end

  # Use to ignore inline messages which lay outside a diff's range, thereby not posting them in the main comment.
  # You can set hash to change behavior per each kinds. (ex. `{warning: true, error: false}`)
  #
  # @param or [Bool] [Hash<Symbol, Bool>] dismiss
  #   Ignore out of range inline messages, defaults to `true`
  # @return [void]
  def dismiss_out_of_range_messages(dismiss = T.unsafe(nil)); end

  # The head commit to which the PR is requesting to be merged from.
  #
  # @return [String]
  def head_commit; end

  # Returns a list of HTML anchors for a file, or files in the head repository. An example would be:
  # `<a href='https://github.com/artsy/eigen/blob/561827e46167077b5e53515b4b7349b8ae04610b/file.txt'>file.txt</a>`. It returns a string of multiple anchors if passed an array.
  #
  # @param paths [String or Array<String>] A list of strings to convert to github anchors
  # @param full_path [Bool] Shows the full path as the link's text, defaults to `true`.
  # @return [String]
  def html_link(paths, full_path: T.unsafe(nil)); end

  def mr_author; end
  def mr_body; end
  def mr_json; end
  def mr_labels; end
  def mr_title; end

  # The username of the author of the Pull Request.
  #
  # @return [String]
  def pr_author; end

  # The body text of the Pull Request.
  #
  # @return [String]
  def pr_body; end

  # The unified diff produced by Github for this PR
  # see [Unified diff](https://en.wikipedia.org/wiki/Diff_utility#Unified_format)
  #
  # @return [String]
  def pr_diff; end

  # Whether the PR is a Draft.
  #
  # @return [Boolean]
  def pr_draft?; end

  # The hash that represents the PR's JSON. For an example of what this looks like
  # see the [Danger Fixture'd one](https://raw.githubusercontent.com/danger/danger/master/spec/fixtures/github_api/pr_response.json).
  #
  # @return [Hash]
  def pr_json; end

  # The labels assigned to the Pull Request.
  #
  # @return [String]
  def pr_labels; end

  # The title of the Pull Request.
  #
  # @return [String]
  def pr_title; end

  # In Beta. Provides access to creating a GitHub Review instead of a typical GitHub comment.
  #
  # To use you announce the start of your review, and the end via the `start` and `submit` functions,
  # for example:
  #
  # github.review.start
  # github.review.fail(message)
  # github.review.warn(message)
  # github.review.message(message)
  # github.review.markdown(message)
  # github.review.submit
  #
  # @return [ReviewDSL]
  def review; end

  private

  def create_link(href, text); end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end

    # So that this init can fail.
    def new(dangerfile); end
  end
end

# Handles interacting with GitLab inside a Dangerfile. Provides a few functions which wrap `mr_json` and also
# through a few standard functions to simplify your code.
#
# @example Warn when an MR is classed as work in progress.
#
#   warn "MR is classed as Work in Progress" if gitlab.mr_title.include? "[WIP]"
# @example Declare a MR to be simple to avoid specific Danger rules.
#
#   declared_trivial = (gitlab.mr_title + gitlab.mr_body).include?("#trivial")
# @example Ensure that labels have been applied to the MR.
#
#   failure "Please add labels to this MR" if gitlab.mr_labels.empty?
# @example Ensure that all MRs have an assignee.
#
#   warn "This MR does not have any assignees yet." unless gitlab.mr_json["assignee"]
# @example Ensure there is a summary for a MR.
#
#   failure "Please provide a summary in the Merge Request description" if gitlab.mr_body.length < 5
# @example Only accept MRs to the develop branch.
#
#   failure "Please re-submit this MR to develop, we may have already fixed your issue." if gitlab.branch_for_merge != "develop"
# @example Note when MRs don't reference a milestone, make the warning stick around on subsequent runs
#
#   has_milestone = gitlab.mr_json["milestone"] != nil
#   warn("This MR does not refer to an existing milestone", sticky: true) unless has_milestone
# @example Note when a MR cannot be manually merged
#
#   can_merge = gitlab.mr_json["mergeable"]
#   warn("This MR cannot be merged yet.") unless can_merge
# @example Highlight when a celebrity makes a merge request.
#
#   message "Welcome, Danger." if gitlab.mr_author == "dangermcshane"
# @example Send a message with links to a collection of specific files.
#
#   if git.modified_files.include? "config/*.js"
#   config_files = git.modified_files.select { |path| path.include? "config/" }
#   message "This MR changes #{ gitlab.html_link(config_files) }"
#   end
# @example Highlight with a clickable link if a Package.json is changed.
#
#   warn "#{gitlab.html_link("Package.json")} was edited." if git.modified_files.include? "Package.json"
# @example Select a random group member as assignee if no assignee is selected
#
#   if gitlab.mr_json["assignee"].nil?
#   reviewer = gitlab.api.group_members(gitlab.api.merge_request_approvals(project_id, mr_id).to_hash["approver_groups"].first["group"]["id"]).sample
#   if gitlab.api.group_members(gitlab.api.merge_request_approvals(project_id, mr_id).to_hash["approver_groups"].first["group"]["id"]).length > 1
#   while reviewer.to_hash["id"] == gitlab.mr_json["author"]["id"] do
#   reviewer = gitlab.api.group_members(gitlab.api.merge_request_approvals(project_id, mr_id).to_hash["approver_groups"].first["group"]["id"]).sample
#   end
#   end
#   message "Reviewer roulete rolled for: #{reviewer.to_hash['name']} (@#{reviewer.to_hash['username']})"
#   gitlab.api.update_merge_request(project_id, mr_id, { assignee_id: reviewer.to_hash["id"] })
#   end
# @see danger/danger
class Danger::DangerfileGitLabPlugin < ::Danger::Plugin
  # @return [DangerfileGitLabPlugin] a new instance of DangerfileGitLabPlugin
  def initialize(dangerfile); end

  # Provides access to the GitLab API client used inside Danger. Making
  # it easy to use the GitLab API inside a Dangerfile. See the gitlab
  # gem's [documentation](http://www.rubydoc.info/gems/gitlab/Gitlab/Client)
  # for accessible methods.
  #
  # @return [GitLab::Client]
  def api; end

  # The base commit to which the MR is going to be merged as a parent
  #
  # @return [String]
  def base_commit; end

  # The branch to which the MR is going to be merged into.
  #
  # @return [String]
  def branch_for_base; end

  # The branch to which the MR is going to be merged from.
  #
  # @return [String]
  def branch_for_head; end

  # The branch to which the MR is going to be merged into
  #
  # @deprecated Please use {#branch_for_base} instead
  # @return [String]
  def branch_for_merge; end

  # Use to ignore inline messages which lay outside a diff's range, thereby not posting the comment.
  # You can set hash to change behavior per each kinds. (ex. `{warning: true, error: false}`)
  #
  # @param or [Bool] [Hash<Symbol, Bool>] dismiss
  #   Ignore out of range inline messages, defaults to `true`
  # @return [void]
  def dismiss_out_of_range_messages(dismiss = T.unsafe(nil)); end

  # The head commit to which the MR is requesting to be merged from
  #
  # @return [String]
  def head_commit; end

  # Returns a list of HTML anchors for a file, or files in the head repository. An example would be:
  # `<a href='https://gitlab.com/artsy/eigen/blob/561827e46167077b5e53515b4b7349b8ae04610b/file.txt'>file.txt</a>`. It returns a string of multiple anchors if passed an array.
  #
  # @param paths [String or Array<String>] A list of strings to convert to gitlab anchors
  # @param full_path [Bool] Shows the full path as the link's text, defaults to `true`.
  # @return [String]
  def html_link(paths, full_path: T.unsafe(nil)); end

  # The username of the author of the Merge Request
  #
  # @return [String]
  def mr_author; end

  # The body text of the Merge Request
  #
  # @return [String]
  def mr_body; end

  # The array of changes
  #
  # @return [Array<Gitlab::ObjectifiedHash>]
  def mr_changes; end

  # The array of issues that this MR closes
  #
  # @return [Array<Gitlab::ObjectifiedHash>]
  def mr_closes_issues; end

  # The unified diff produced by GitLab for this MR
  # see [Unified diff](https://en.wikipedia.org/wiki/Diff_utility#Unified_format)
  #
  # @return [String]
  def mr_diff; end

  # The hash that represents the MR's JSON. See documentation for the
  # structure [here](http://docs.gitlab.com/ce/api/merge_requests.html#get-single-mr)
  #
  # @return [Hash]
  def mr_json; end

  # The labels assigned to the Merge Request
  #
  # @return [String]
  def mr_labels; end

  # The title of the Merge Request
  #
  # @return [String]
  def mr_title; end

  def pr_author; end
  def pr_body; end
  def pr_diff; end
  def pr_json; end
  def pr_labels; end
  def pr_title; end

  # Returns the web_url of the source project.
  #
  # @return [String]
  def repository_web_url; end

  private

  def create_link(href, text); end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end

    # So that this init can fail.
    def new(dangerfile); end
  end
end

# Handles interacting with git inside a Dangerfile. Providing access to files that have changed, and useful statistics. Also provides
# access to the commits in the form of [Git::Log](https://github.com/schacon/ruby-git/blob/master/lib/git/log.rb) objects.
#
# @example Do something to all new and edited markdown files
#
#   markdowns = (git.added_files + git.modified_files)
#   do_something markdowns.select{ |file| file.end_with? "md" }
# @example Don't allow a file to be deleted
#
#   deleted = git.deleted_files.include? "my/favourite.file"
#   failure "Don't delete my precious" if deleted
# @example Fail really big diffs
#
#   failure "We cannot handle the scale of this PR" if git.lines_of_code > 50_000
# @example Warn when there are merge commits in the diff
#
#   if git.commits.any? { |c| c.message =~ /^Merge branch 'master'/ }
#   warn 'Please rebase to get rid of the merge commits in this PR'
#   end
# @example Warn when somebody tries to add nokogiri to the project
#
#   diff = git.diff_for_file("Gemfile.lock")
#   if diff && diff.patch =~ "nokogiri"
#   warn 'Please do not add nokogiri to the project. Thank you.'
#   end
# @see danger/danger
class Danger::DangerfileGitPlugin < ::Danger::Plugin
  # @return [DangerfileGitPlugin] a new instance of DangerfileGitPlugin
  def initialize(dangerfile); end

  # Paths for files that were added during the diff
  #
  # @return [FileList<String>] an [Array] subclass
  def added_files; end

  # The log of commits inside the diff
  #
  # @return [Git::Log] from the gem `git`
  def commits; end

  # Paths for files that were removed during the diff
  #
  # @return [FileList<String>] an [Array] subclass
  def deleted_files; end

  # The overall lines of code removed in the diff
  #
  # @return [Fixnum]
  def deletions; end

  # Whole diff
  #
  # @return [Git::Diff] from the gem `git`
  def diff; end

  # Details for a specific file in this diff
  #
  # @return [Git::Diff::DiffFile] from the gem `git`
  def diff_for_file(file); end

  # Statistics for a specific file in this diff
  #
  # @return [Hash] with keys `:insertions`, `:deletions` giving line counts, and `:before`, `:after` giving file contents, or nil if the file has no changes or does not exist
  def info_for_file(file); end

  # The overall lines of code added in the diff
  #
  # @return [Fixnum]
  def insertions; end

  # The overall lines of code added/removed in the diff
  #
  # @return [Fixnum]
  def lines_of_code; end

  # Paths for files that changed during the diff
  #
  # @return [FileList<String>] an [Array] subclass
  def modified_files; end

  # List of renamed files
  #
  # @return [Array<Hash>] with keys `:before` and `:after`
  def renamed_files; end

  # List of remote tags
  #
  # @return [String]
  def tags; end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end
  end
end

class Danger::DangerfileInit < ::Danger::DangerfileCommand
  def run; end
end

# Handles interacting with local only plugin inside a Dangerfile.
# It is support pluggin for dry_run command and does not expose any methods.
# But you can still use other plugins like git
#
# @example Check that added lines contains agreed form of words
#
#   git.diff.each do |chunk|
#   chunk.patch.lines.grep(/^\+/).each do |added_line|
#   if added_line.gsub!(/(?<cancel>cancel)(?<rest>[^l[[:space:]][[:punct:]]]+)/i, '>>\k<cancel>-l-\k<rest><<')
#   fail "Single 'L' for cancellation-alike words in '#{added_line}'"
#   end
#   end
#   end
# @see danger/danger
class Danger::DangerfileLocalOnlyPlugin < ::Danger::Plugin
  # @return [DangerfileLocalOnlyPlugin] a new instance of DangerfileLocalOnlyPlugin
  def initialize(dangerfile); end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end

    # So that this init can fail.
    def new(dangerfile); end
  end
end

# Provides the feedback mechanism for Danger. Danger can keep track of
# messages, warnings, failure and post arbitrary markdown into a comment.
#
# The message within which Danger communicates back is amended on each run in a session.
#
# Each of `message`, `warn` and `fail` have a `sticky` flag, `false` by default, which
# when `true` means that the message will be crossed out instead of being removed.
# If it's not called again on subsequent runs.
#
# Each of `message`, `warn`, `fail` and `markdown` support multiple passed arguments
# message 'Hello', 'World', file: "Dangerfile", line: 1
# warn ['This', 'is', 'warning'], file: "Dangerfile", line: 1
# failure 'Ooops', 'bad bad error', sticky: false
# markdown '# And', '# Even', '# Markdown', file: "Dangerfile", line: 1
#
# By default, using `failure` would fail the corresponding build. Either via an API call, or
# via the return value for the danger command. Older code examples use `fail` which is an alias
# of `failure`, but the default Rubocop settings would have an issue with it.
#
# You can optionally add `file` and `line` to provide inline feedback on a PR in GitHub, note that
# only feedback inside the PR's diff will show up inline. Others will appear inside the main comment.
#
# It is possible to have Danger ignore specific warnings or errors by writing `Danger: Ignore "[warning/error text]"`.
#
# Sidenote: Messaging is the only plugin which adds functions to the root of the Dangerfile.
#
# @example Failing a build
#
#   failure "This build didn't pass tests"
#   failure "Ooops!", "Something bad happened"
#   failure ["This is example", "with array"]
# @example Failing a build, and note that on subsequent runs
#
#   failure("This build didn't pass tests", sticky: true)
# @example Passing a warning
#
#   warn "This build didn't pass linting"
#   warn "Hm...", "This is not really good"
#   warn ["Multiple warnings", "via array"]
# @example Displaying a markdown table
#
#   message = "### Proselint found issues\n\n"
#   message << "Line | Message | Severity |\n"
#   message << "| --- | ----- | ----- |\n"
#   message << "20 | No documentation | Error \n"
#   markdown message
#
#   markdown "### First issue", "### Second issue"
#   markdown ["### First issue", "### Second issue"]
# @example Adding an inline warning to a file
#
#   warn("You shouldn't use puts in your Dangerfile", file: "Dangerfile", line: 10)
# @see danger/danger
class Danger::DangerfileMessagingPlugin < ::Danger::Plugin
  # @return [DangerfileMessagingPlugin] a new instance of DangerfileMessagingPlugin
  def initialize(dangerfile); end

  # Declares a CI blocking error
  #
  # @param message [String, Array<String>] The message to present to the user
  # @param sticky [Boolean] Whether the message should be kept after it was fixed,
  #   defaults to `false`.
  # @param file [String] Optional. Path to the file that the message is for.
  # @param line [String] Optional. The line in the file to present the message in.
  # @return [void]
  def fail(*failures, **options); end

  # Declares a CI blocking error
  #
  # @param message [String, Array<String>] The message to present to the user
  # @param sticky [Boolean] Whether the message should be kept after it was fixed,
  #   defaults to `false`.
  # @param file [String] Optional. Path to the file that the message is for.
  # @param line [String] Optional. The line in the file to present the message in.
  # @return [void]
  def failure(*failures, **options); end

  # Print markdown to below the table
  #
  # @param message [String, Array<String>] The markdown based message to be printed below the table
  # @param file [String] Optional. Path to the file that the message is for.
  # @param line [String] Optional. The line in the file to present the message in.
  # @return [void]
  def markdown(*markdowns, **options); end

  # Print out a generate message on the PR
  #
  # @param message [String, Array<String>] The message to present to the user
  # @param sticky [Boolean] Whether the message should be kept after it was fixed,
  #   defaults to `false`.
  # @param file [String] Optional. Path to the file that the message is for.
  # @param line [String] Optional. The line in the file to present the message in.
  # @return [void]
  def message(*messages, **options); end

  # A list of all messages passed to Danger, including
  # the markdowns.
  #
  # @return [Hash]
  def status_report; end

  # A list of all violations passed to Danger, we don't
  # anticipate users of Danger needing to use this.
  #
  # @return [Hash]
  def violation_report; end

  # Specifies a problem, but not critical
  #
  # @param message [String, Array<String>] The message to present to the user
  # @param sticky [Boolean] Whether the message should be kept after it was fixed,
  #   defaults to `false`.
  # @param file [String] Optional. Path to the file that the message is for.
  # @param line [String] Optional. The line in the file to present the message in.
  # @return [void]
  def warn(*warnings, **options); end

  private

  def should_ignore_violation(message); end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end
  end
end

# Handles interacting with VSTS inside a Dangerfile. Provides a few functions which wrap `pr_json` and also
# through a few standard functions to simplify your code.
#
# @example Warn when a PR is classed as work in progress
#
#   warn "PR is classed as Work in Progress" if vsts.pr_title.include? "[WIP]"
# @example Declare a PR to be simple to avoid specific Danger rules
#
#   declared_trivial = (vsts.pr_title + vsts.pr_body).include?("#trivial")
# @example Ensure there is a summary for a PR
#
#   failure "Please provide a summary in the Pull Request description" if vsts.pr_body.length < 5
# @example Only accept PRs to the develop branch
#
#   failure "Please re-submit this PR to develop, we may have already fixed your issue." if vsts.branch_for_base != "develop"
# @example Highlight when a celebrity makes a pull request
#
#   message "Welcome, Danger." if vsts.pr_author == "dangermcshane"
# @example Ensure that all PRs have an assignee
#
#   warn "This PR does not have any assignees yet." unless vsts.pr_json["reviewers"].length == 0
# @example Send a message with links to a collection of specific files
#
#   if git.modified_files.include? "config/*.js"
#   config_files = git.modified_files.select { |path| path.include? "config/" }
#   message "This PR changes #{ vsts.markdown_link(config_files) }"
#   end
# @example Highlight with a clickable link if a Package.json is changed
#
#   warn "#{vsts.markdown_link("Package.json")} was edited." if git.modified_files.include? "Package.json"
# @example Note an issue with a particular line on a file using the #L[num] syntax, e.g. `#L23`
#
#   linter_json = `my_linter lint "file"`
#   results = JSON.parse linter_json
#   unless results.empty?
#   file, line, warning = result.first
#   warn "#{vsts.markdown_link("#{file}#L#{line}")} has linter issue: #{warning}."
#   end
# @see danger/danger
class Danger::DangerfileVSTSPlugin < ::Danger::Plugin
  # @return [DangerfileVSTSPlugin] a new instance of DangerfileVSTSPlugin
  def initialize(dangerfile); end

  # The base commit to which the PR is going to be merged as a parent.
  #
  # @return [String]
  def base_commit; end

  # The branch to which the PR is going to be merged into.
  #
  # @return [String]
  def branch_for_base; end

  # The branch to which the PR is going to be merged from.
  #
  # @return [String]
  def branch_for_head; end

  # The head commit to which the PR is requesting to be merged from.
  #
  # @return [String]
  def head_commit; end

  # Returns a list of Markdown links for a file, or files in the head repository.
  # It returns a string of multiple links if passed an array.
  #
  # @param paths [String or Array<String>] A list of strings to convert to Markdown links
  # @param full_path [Bool] Shows the full path as the link's text, defaults to `true`.
  # @return [String]
  def markdown_link(paths, full_path: T.unsafe(nil)); end

  # The username of the author of the Pull Request.
  #
  # @return [String]
  def pr_author; end

  # The body text of the Pull Request.
  #
  # @return [String]
  def pr_body; end

  # The body text of the Pull Request.
  #
  # @return [String]
  def pr_description; end

  # The hash that represents the PR's JSON. For an example of what this looks like
  # see the [Danger Fixture'd one](https://raw.githubusercontent.com/danger/danger/master/spec/fixtures/vsts_api/pr_response.json).
  #
  # @return [Hash]
  def pr_json; end

  # A href that represents the current PR
  #
  # @return [String]
  def pr_link; end

  # The title of the Pull Request.
  #
  # @return [String]
  def pr_title; end

  private

  def branch_name(key); end
  def create_markdown_link(href, text); end

  class << self
    # The instance name used in the Dangerfile
    #
    # @return [String]
    def instance_name; end

    # So that this init can fail.
    def new(dangerfile); end
  end
end

# ### CI Setup
# DotCi is a layer on top of jenkins. So, if you're using DotCi, you're hosting your own environment.
#
# ### Token Setup
#
# #### GitHub
# As you own the machine, it's up to you to add the environment variable for the `DANGER_GITHUB_API_TOKEN`.
class Danger::DotCi < ::Danger::CI
  # @return [DotCi] a new instance of DotCi
  def initialize(env); end

  def supported_request_sources; end

  class << self
    def pull_request_id(env); end
    def repo_url(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# With Drone you run the docker images yourself, so you will want to add `bundle exec danger` at the end of
# your `.drone.yml`.
#
#  ```shell
#   build:
#     image: golang
#     commands:
#       - ...
#       - bundle exec danger
#  ```
#
# ### Token Setup
#
# As this is self-hosted, you will need to expose the `DANGER_GITHUB_API_TOKEN` as a secret to your
# builds:
#
# Drone secrets: http://readme.drone.io/usage/secret-guide/
# NOTE: This is a new syntax in DroneCI 0.6+
#
# ```yml
#   build:
#     image: golang
#     secrets:
#       - DANGER_GITHUB_API_TOKEN
#     commands:
#       - ...
#       - bundle exec danger
# ```
class Danger::Drone < ::Danger::CI
  # @return [Drone] a new instance of Drone
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # Check if this build is valid for CI with drone 0.6 or later
    #
    # @return [Boolean]
    def validates_as_ci_post_06?(env); end

    # Checks if this build is valid for CI with drone 0.5 or earlier
    #
    # @return [Boolean]
    def validates_as_ci_pre_06?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

class Danger::DryRun < ::Danger::Runner
  # @return [DryRun] a new instance of DryRun
  def initialize(argv); end

  def run; end
  def validate!; end

  class << self
    def options; end
  end
end

class Danger::EmojiMapper
  # @return [EmojiMapper] a new instance of EmojiMapper
  def initialize(template); end

  def from_type(type); end
  def map(emoji); end

  private

  # Returns the value of attribute template.
  def template; end
end

Danger::EmojiMapper::DATA = T.let(T.unsafe(nil), Hash)
Danger::EmojiMapper::TYPE_TO_EMOJI = T.let(T.unsafe(nil), Hash)

class Danger::EnvironmentManager
  # @return [EnvironmentManager] a new instance of EnvironmentManager
  def initialize(env, ui = T.unsafe(nil), danger_id = T.unsafe(nil)); end

  # Returns the value of attribute ci_source.
  def ci_source; end

  # Sets the attribute ci_source
  #
  # @param value the value to set the attribute ci_source to.
  def ci_source=(_arg0); end

  def clean_up; end

  # Returns the value of attribute danger_id.
  def danger_id; end

  # Sets the attribute danger_id
  #
  # @param value the value to set the attribute danger_id to.
  def danger_id=(_arg0); end

  def ensure_danger_branches_are_setup; end
  def fill_environment_vars; end
  def meta_info_for_base; end
  def meta_info_for_head; end

  # @return [Boolean]
  def pr?; end

  def raise_error_for_no_request_source(env, ui); end

  # Returns the value of attribute request_source.
  def request_source; end

  # Sets the attribute request_source
  #
  # @param value the value to set the attribute request_source to.
  def request_source=(_arg0); end

  # Returns the value of attribute scm.
  def scm; end

  # Sets the attribute scm
  #
  # @param value the value to set the attribute scm to.
  def scm=(_arg0); end

  # Returns the value of attribute ui.
  def ui; end

  # Sets the attribute ui
  #
  # @param value the value to set the attribute ui to.
  def ui=(_arg0); end

  private

  def extract_title_and_subtitle_from_source(repo_url); end
  def get_repo_source(repo_url); end
  def travis_note; end
  def ui_display_no_request_source_error_message(ui, env, title, subtitle); end

  class << self
    # @return [String] danger's default base branch
    def danger_base_branch; end

    # @return [String] danger's default head branch
    def danger_head_branch; end

    # Finds a Danger::CI class based on the ENV
    def local_ci_source(env); end

    # Uses the current Danger::CI subclass, and sees if it is a PR
    #
    # @return [Boolean]
    def pr?(env); end
  end
end

class Danger::Executor
  # @return [Executor] a new instance of Executor
  def initialize(system_env); end

  def run(env: T.unsafe(nil), dm: T.unsafe(nil), cork: T.unsafe(nil), base: T.unsafe(nil), head: T.unsafe(nil), dangerfile_path: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), fail_on_errors: T.unsafe(nil), fail_if_no_pr: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
  def validate!(cork, fail_if_no_pr: T.unsafe(nil)); end

  private

  def base_branch(user_specified_base_branch); end
  def commit_request(ci_name); end
  def head_branch(user_specified_head_branch); end

  # Returns the value of attribute system_env.
  def system_env; end

  # Could we find a CI source at all?
  def validate_ci!; end

  # Could we determine that the CI source is inside a PR?
  def validate_pr!(cork, fail_if_no_pr); end
end

class Danger::FileList
  include ::Comparable
  include ::Danger::Helpers::ArraySubclass

  # Information about pattern: http://ruby-doc.org/core-2.2.0/File.html#method-c-fnmatch
  # e.g. "**/something.*" for any file called something with any extension
  #
  # @return [Boolean]
  def include?(pattern); end
end

class Danger::FindRepoInfoFromLogs
  # @return [FindRepoInfoFromLogs] a new instance of FindRepoInfoFromLogs
  def initialize(github_host, remote_logs); end

  def call; end

  private

  # Returns the value of attribute github_host.
  def github_host; end

  def regexp; end
  def remote; end

  # Returns the value of attribute remote_logs.
  def remote_logs; end
end

class Danger::FindRepoInfoFromURL
  # @return [FindRepoInfoFromURL] a new instance of FindRepoInfoFromURL
  def initialize(url); end

  def call; end

  private

  # Returns the value of attribute url.
  def url; end
end

Danger::FindRepoInfoFromURL::REGEXP = T.let(T.unsafe(nil), Regexp)

# Regex used to extract info from Bitbucket server URLs, as they use a quite different format
Danger::FindRepoInfoFromURL::REGEXPBB = T.let(T.unsafe(nil), Regexp)

Danger::GEM_NAME = T.let(T.unsafe(nil), String)

class Danger::GemsResolver
  # @return [GemsResolver] a new instance of GemsResolver
  def initialize(gem_names); end

  # Returns an Array of paths (plugin lib file paths) and gems (of metadata)
  def call; end

  private

  def all_gems_metadata; end
  def create_gemfile_from_gem_names; end

  # Returns the value of attribute dir.
  def dir; end

  def gem_metadata(gem); end

  # Returns the value of attribute gem_names.
  def gem_names; end

  def gems; end

  # The paths are relative to dir.
  def paths; end

  def real_gems; end
end

# ### CI Setup
#
# You can use `danger/danger` Action in your `.github/workflows/xxx.yml`.
# And so, you can use GITHUB_TOKEN secret as `DANGER_GITHUB_API_TOKEN` environment variable.
#
#  ```yml
#  ...
#    steps:
#      - uses: actions/checkout@v1
#      - uses: danger/danger@master
#        env:
#          DANGER_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#  ```
class Danger::GitHubActions < ::Danger::CI
  # @return [GitHubActions] a new instance of GitHubActions
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# Install dependencies and add a danger step to your .gitlab-ci.yml:
#
# ```yml
# before_script:
#  - bundle install
# danger:
#   script:
#    - bundle exec danger
# ```
#
# ### Token Setup
#
# Add the `DANGER_GITLAB_API_TOKEN` to your pipeline env variables if you
# are hosting your code on GitLab. If you are using GitLab as a mirror
# for the purpose of CI/CD, while hosting your repo on GitHub, set the
# `DANGER_GITHUB_API_TOKEN` as well as the project repo URL to
# `DANGER_PROJECT_REPO_URL`.
class Danger::GitLabCI < ::Danger::CI
  # @return [GitLabCI] a new instance of GitLabCI
  def initialize(env); end

  def supported_request_sources; end

  class << self
    def determine_pull_or_merge_request_id(env); end
    def slug_from(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

class Danger::GitRepo
  # Returns the value of attribute diff.
  def diff; end

  # Sets the attribute diff
  #
  # @param value the value to set the attribute diff to.
  def diff=(_arg0); end

  def diff_for_folder(folder, from: T.unsafe(nil), to: T.unsafe(nil), lookup_top_level: T.unsafe(nil)); end
  def ensure_commitish_exists!(commitish); end
  def ensure_commitish_exists_on_branch!(branch, commitish); end
  def exec(string); end

  # Returns the value of attribute folder.
  def folder; end

  # Sets the attribute folder
  #
  # @param value the value to set the attribute folder to.
  def folder=(_arg0); end

  def head_commit; end

  # Returns the value of attribute log.
  def log; end

  # Sets the attribute log
  #
  # @param value the value to set the attribute log to.
  def log=(_arg0); end

  def origins; end
  def renamed_files; end
  def tags; end

  private

  # @return [Boolean]
  def commit_exists?(sha1); end

  # @return [Boolean]
  def commit_is_ref?(commit); end

  # @return [Boolean]
  def commit_not_exists?(sha1); end

  def commits_in_branch_count(from, to); end
  def default_env; end
  def find_merge_base(repo, from, to); end
  def find_merge_base_with_incremental_fetch(repo, from, to); end
  def git_fetch_branch_to_depth(branch, depth); end
  def git_in_depth_fetch; end
  def possible_merge_base(repo, from, to); end
  def raise_if_we_cannot_find_the_commit(commitish); end
end

class Danger::HTTPCache
  # @return [HTTPCache] a new instance of HTTPCache
  def initialize(cache_file = T.unsafe(nil), options = T.unsafe(nil)); end

  def delete(key); end
  def entry_has_expired(entry, ttl); end

  # Returns the value of attribute expires_in.
  def expires_in; end

  def read(key); end
  def write(key, value); end
end

module Danger::Helpers; end

module Danger::Helpers::ArraySubclass
  include ::Comparable

  def initialize(array); end

  def <=>(other); end

  # @return [Boolean]
  def kind_of?(compare_class); end

  def method_missing(name, *args, &block); end
  def to_a; end
  def to_ary; end

  private

  # Returns the value of attribute __array__.
  def __array__; end

  # Sets the attribute __array__
  #
  # @param value the value to set the attribute __array__ to.
  def __array__=(_arg0); end

  def dummy; end
  def respond_to_method(name, *args, &block); end

  # @return [Boolean]
  def respond_to_missing?(name, include_all); end
end

module Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper

  def apply_template(tables: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), template: T.unsafe(nil), request_source: T.unsafe(nil)); end
  def generate_comment(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), previous_violations: T.unsafe(nil), danger_id: T.unsafe(nil), template: T.unsafe(nil)); end
  def generate_description(warnings: T.unsafe(nil), errors: T.unsafe(nil), template: T.unsafe(nil)); end
  def generate_inline_comment_body(emoji, message, danger_id: T.unsafe(nil), resolved: T.unsafe(nil), template: T.unsafe(nil)); end
  def generate_inline_markdown_body(markdown, danger_id: T.unsafe(nil), template: T.unsafe(nil)); end

  # resolved is essentially reserved for future use - eventually we might
  # have some nice generic resolved-thing going :)
  def generate_message_group_comment(message_group:, danger_id: T.unsafe(nil), resolved: T.unsafe(nil), template: T.unsafe(nil)); end

  # !@group Extension points
  # Produces a markdown link to the file the message points to
  #
  # request_source implementations are invited to override this method with their
  # vendor specific link.
  #
  # @param message [Violation or Markdown]
  # @param Should [Bool] hide any generated link created
  # @return [String] The Markdown compatible link
  def markdown_link_to_message(message, hide_link); end

  def markdown_parser(text); end

  # !@group Extension points
  # Determine whether two messages are equivalent
  #
  # request_source implementations are invited to override this method.
  # This is mostly here to enable sources to detect when inlines change only in their
  # commit hash and not in content per-se. since the link is implementation dependant
  # so should be the comparison.
  #
  # @param m1 [Violation or Markdown]
  # @param m2 [Violation or Markdown]
  # @return [Boolean] whether they represent the same message
  def messages_are_equivalent(m1, m2); end

  def process_markdown(violation, hide_link = T.unsafe(nil)); end
  def random_compliment; end
  def table(name, emoji, violations, all_previous_violations, template: T.unsafe(nil)); end

  private

  def pluralize(string, count); end
  def truncate(string); end
end

module Danger::Helpers::CommentsParsingHelper
  def parse_comment(comment); end

  # !@group Extension points
  # Produces a message-like from a row in a comment table
  #
  # @param row [String] The content of the row in the table
  # @return [Violation or Markdown] the extracted message
  def parse_message_from_row(row); end

  def parse_tables_from_comment(comment); end
  def table_kind_from_title(title); end
  def violations_from_table(table); end

  private

  # @return [Boolean]
  def danger_table?(table); end
end

Danger::Helpers::CommentsParsingHelper::GITHUB_OLD_REGEX = T.let(T.unsafe(nil), Regexp)
Danger::Helpers::CommentsParsingHelper::NEW_REGEX = T.let(T.unsafe(nil), Regexp)

module Danger::Helpers::MessageGroupsArrayHelper
  def counts; end
  def fake_errors_array; end
  def fake_warnings_array; end
end

class Danger::Helpers::MessageGroupsArrayHelper::FakeArray < ::Struct
  # Returns the value of attribute count
  #
  # @return [Object] the current value of count
  def count; end

  # Sets the attribute count
  #
  # @param value [Object] the value to set the attribute count to.
  # @return [Object] the newly set value
  def count=(_); end

  # @return [Boolean]
  def empty?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Danger::Init < ::Danger::Runner
  # @return [Init] a new instance of Init
  def initialize(argv); end

  def circle_token; end

  # @return [Boolean]
  def considered_an_oss_repo?; end

  def current_repo_slug; end

  # @return [Boolean]
  def darwin?; end

  def info; end
  def note_about_clicking_links; end
  def run; end
  def setup_access_token; end
  def setup_danger_ci; end
  def setup_dangerfile; end
  def setup_github_account; end
  def show_todo_state; end
  def thanks; end
  def travis_token; end

  # Returns the value of attribute ui.
  def ui; end

  # Sets the attribute ui
  #
  # @param value the value to set the attribute ui to.
  def ui=(_arg0); end

  def unsure_ci; end
  def unsure_token; end
  def uses_circle; end
  def uses_travis; end

  class << self
    def options; end
  end
end

class Danger::Interviewer
  # @return [Interviewer] a new instance of Interviewer
  def initialize(cork_board); end

  def ask_with_answers(question, possible_answers); end
  def green_bang; end
  def header(title); end
  def link(url); end

  # Returns the value of attribute no_delay.
  def no_delay; end

  # Sets the attribute no_delay
  #
  # @param value the value to set the attribute no_delay to.
  def no_delay=(_arg0); end

  # Returns the value of attribute no_waiting.
  def no_waiting; end

  # Sets the attribute no_waiting
  #
  # @param value the value to set the attribute no_waiting to.
  def no_waiting=(_arg0); end

  def pause(time); end
  def red_bang; end
  def run_command(command, output_command = T.unsafe(nil)); end
  def say(output); end
  def show_prompt; end

  # Returns the value of attribute ui.
  def ui; end

  # Sets the attribute ui
  #
  # @param value the value to set the attribute ui to.
  def ui=(_arg0); end

  def wait_for_return; end
  def yellow_bang; end
end

# ### CI Setup
# Ah Jenkins, so many memories. So, if you're using Jenkins, you're hosting your own environment.
#
# #### GitHub
# You will want to be using the [GitHub pull request builder plugin](https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin)
# in order to ensure that you have the build environment set up for PR integration.
#
# With that set up, you can edit your job to add `bundle exec danger` at the build action.
#
# ##### Pipeline
# If your're using [pipelines](https://jenkins.io/solutions/pipeline/) you should be using the [GitHub branch source plugin](https://wiki.jenkins-ci.org/display/JENKINS/GitHub+Branch+Source+Plugin)
# for easy setup and handling of PRs.
#
# After you've set up the plugin, add a `sh 'bundle exec danger'` line in your pipeline script and make sure that build PRs is enabled.
#
# #### GitLab
# You will want to be using the [GitLab Plugin](https://github.com/jenkinsci/gitlab-plugin)
# in order to ensure that you have the build environment set up for MR integration.
#
# With that set up, you can edit your job to add `bundle exec danger` at the build action.
#
# #### General
#
# People occasionally see issues with Danger not classing your CI runs as a PR, to give you visibilty
# the Jenkins side of Danger expects to see one of these env vars:
# - ghprbPullId
# - CHANGE_ID
# - gitlabMergeRequestIid
# - gitlabMergeRequestId
#
# ### Token Setup
#
# #### GitHub
# As you own the machine, it's up to you to add the environment variable for the `DANGER_GITHUB_API_TOKEN`.
#
# #### GitLab
# As you own the machine, it's up to you to add the environment variable for the `DANGER_GITLAB_API_TOKEN`.
class Danger::Jenkins < ::Danger::CI
  # @raise [EnvNotFound]
  # @return [Jenkins] a new instance of Jenkins
  def initialize(env); end

  # Returns the value of attribute project_url.
  def project_url; end

  # Sets the attribute project_url
  #
  # @param value the value to set the attribute project_url to.
  def project_url=(_arg0); end

  def supported_request_sources; end

  class << self
    def pull_request_id(env); end
    def repo_slug(repo_url); end
    def repo_url(env); end
    def slug_bitbucket(repo_url); end
    def slug_fallback(repo_url); end
    def slug_http(repo_url); end
    def slug_ssh(repo_url); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

class Danger::Jenkins::EnvNotFound < ::StandardError
  # @return [EnvNotFound] a new instance of EnvNotFound
  def initialize; end
end

class Danger::Local < ::Danger::Runner
  # @return [Local] a new instance of Local
  def initialize(argv); end

  def run; end
  def validate!; end

  private

  #  this method is a duplicate of Commands::PR#configure_octokit
  # - worth a refactor sometime?
  def configure_octokit(cache_dir); end

  class << self
    def options; end
  end
end

# ignore
class Danger::LocalGitRepo < ::Danger::CI
  # @return [LocalGitRepo] a new instance of LocalGitRepo
  def initialize(env = T.unsafe(nil)); end

  # Returns the value of attribute base_commit.
  def base_commit; end

  # Sets the attribute base_commit
  #
  # @param value the value to set the attribute base_commit to.
  def base_commit=(_arg0); end

  def git; end

  # Returns the value of attribute head_commit.
  def head_commit; end

  # Sets the attribute head_commit
  #
  # @param value the value to set the attribute head_commit to.
  def head_commit=(_arg0); end

  def run_git(command); end
  def supported_request_sources; end

  private

  def commits; end
  def find_pull_request(env); end
  def find_remote_info(env); end

  # Returns the value of attribute found_pull_request.
  def found_pull_request; end

  # @return [Boolean]
  def given_pull_request_url?(env); end

  def missing_remote_error_message; end
  def raise_error_for_missing_remote; end

  # Returns the value of attribute remote_info.
  def remote_info; end

  def sha; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(_env); end
  end
end

# ### CI Setup
#
# For setting up LocalOnlyGitRepo there is not much needed. Either `--base` and `--head` need to be specified or
# origin/master is expected for base and HEAD for head
class Danger::LocalOnlyGitRepo < ::Danger::CI
  # @return [LocalOnlyGitRepo] a new instance of LocalOnlyGitRepo
  def initialize(env = T.unsafe(nil)); end

  # Returns the value of attribute base_commit.
  def base_commit; end

  # Sets the attribute base_commit
  #
  # @param value the value to set the attribute base_commit to.
  def base_commit=(_arg0); end

  def git; end

  # Returns the value of attribute head_commit.
  def head_commit; end

  # Sets the attribute head_commit
  #
  # @param value the value to set the attribute head_commit to.
  def head_commit=(_arg0); end

  def run_git(command); end
  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(_env); end
  end
end

Danger::LocalOnlyGitRepo::BASE_VAR = T.let(T.unsafe(nil), String)
Danger::LocalOnlyGitRepo::HEAD_VAR = T.let(T.unsafe(nil), String)

class Danger::LocalPullRequest
  # @return [LocalPullRequest] a new instance of LocalPullRequest
  def initialize(log_line); end

  # Returns the value of attribute pull_request_id.
  def pull_request_id; end

  # Returns the value of attribute sha.
  def sha; end

  # @return [Boolean]
  def valid?; end
end

class Danger::LocalSetup
  # @return [LocalSetup] a new instance of LocalSetup
  def initialize(dangerfile, cork); end

  # Returns the value of attribute cork.
  def cork; end

  # Returns the value of attribute dm.
  def dm; end

  def setup(verbose: T.unsafe(nil)); end
end

class Danger::Markdown < ::Danger::BaseMessage
  # @return [Markdown] a new instance of Markdown
  def initialize(message, file = T.unsafe(nil), line = T.unsafe(nil)); end

  def <=>(other); end
  def ==(other); end
  def hash; end
  def to_s; end
end

class Danger::MessageAggregator
  # @return [MessageAggregator] a new instance of MessageAggregator
  def initialize(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  # aggregates the messages into an array of MessageGroups
  #
  # @return [[MessageGroup]]
  def aggregate; end

  class << self
    def aggregate(*args); end
  end
end

class Danger::MessageGroup
  # @return [MessageGroup] a new instance of MessageGroup
  def initialize(file: T.unsafe(nil), line: T.unsafe(nil)); end

  # Adds a message to the group.
  #
  # @param message [Markdown, Violation] the message to add
  def <<(message); end

  # Returns the value of attribute file.
  def file; end

  # Returns the value of attribute line.
  def line; end

  def markdowns; end

  # Merges two `MessageGroup`s that represent the same line of code
  # In future, perhaps `MessageGroup` will be able to represent a group of
  # messages for multiple lines.
  #
  # @raise [ArgumentError]
  def merge(other); end

  # The list of messages in this group. This list will be sorted in decreasing
  # order of severity (error, warning, message, markdown)
  def messages; end

  # Returns whether this `MessageGroup` is for the same line of code as
  #   `other`, taking which file they are in to account.
  #
  # @param other [MessageGroup, Markdown, Violation]
  # @return [Boolean] whether this `MessageGroup` is for the same line of code
  def same_line?(other); end

  # :errors_count
  #
  # @return a hash of statistics. Currently only :warnings_count and
  def stats; end
end

class Danger::NoPullRequest
  # @return [Boolean]
  def valid?; end
end

class Danger::NoRepoInfo
  # Returns the value of attribute id.
  def id; end

  # Returns the value of attribute slug.
  def slug; end
end

class Danger::PR < ::Danger::Runner
  # @return [PR] a new instance of PR
  def initialize(argv); end

  def run; end
  def validate!; end

  private

  def configure_octokit(cache_dir); end

  class << self
    def options; end
  end
end

class Danger::Plugin
  # @return [Plugin] a new instance of Plugin
  def initialize(dangerfile); end

  def method_missing(method_sym, *arguments, **keyword_arguments, &block); end

  private

  # When using `danger local --pry`, every plugin had an unreasonable
  # amount of text output due to the Dangerfile reference in every
  # plugin. So, it is filtered out. Users will start out in the context
  # of the Dangerfile, and can view it by just typing `self` into the REPL.
  def pretty_print_instance_variables; end

  class << self
    def all_plugins; end
    def clear_external_plugins; end

    # @private
    def inherited(plugin); end

    def instance_name; end
  end
end

class Danger::PluginFileResolver
  # Takes an array of files, gems or nothing, then resolves them into
  # paths that should be sent into the documentation parser
  #
  # @return [PluginFileResolver] a new instance of PluginFileResolver
  def initialize(references); end

  # When given existing paths, map to absolute & existing paths
  # When given a list of gems, resolve for list of gems
  # When empty, imply you want to test the current lib folder as a plugin
  def resolve; end

  private

  # Returns the value of attribute refs.
  def refs; end
end

class Danger::PluginJSON < ::CLAide::Command::Plugins
  # @return [PluginJSON] a new instance of PluginJSON
  def initialize(argv); end

  # Returns the value of attribute cork.
  def cork; end

  # Sets the attribute cork
  #
  # @param value the value to set the attribute cork to.
  def cork=(_arg0); end

  def run; end
end

class Danger::PluginLint < ::CLAide::Command::Plugins
  # @return [PluginLint] a new instance of PluginLint
  def initialize(argv); end

  # Returns the value of attribute cork.
  def cork; end

  # Sets the attribute cork
  #
  # @param value the value to set the attribute cork to.
  def cork=(_arg0); end

  def run; end

  class << self
    def options; end
  end
end

class Danger::PluginLinter
  # @return [PluginLinter] a new instance of PluginLinter
  def initialize(json); end

  # Returns the value of attribute errors.
  def errors; end

  # Sets the attribute errors
  #
  # @param value the value to set the attribute errors to.
  def errors=(_arg0); end

  # Did the linter pass/fail?
  #
  # @return [Boolean]
  def failed?; end

  # Returns the value of attribute json.
  def json; end

  # Sets the attribute json
  #
  # @param value the value to set the attribute json to.
  def json=(_arg0); end

  # Lints the current JSON, looking at:
  # * Class rules
  # * Method rules
  # * Attribute rules
  def lint; end

  # Prints a summary of the errors and warnings.
  def print_summary(ui); end

  # Returns the value of attribute warnings.
  def warnings; end

  # Sets the attribute warnings
  #
  # @param value the value to set the attribute warnings to.
  def warnings=(_arg0); end

  private

  # Runs the rule, if it fails then additional metadata
  # is added to the rule (for printing later) and it's
  # added to either `warnings` or `errors`.
  def apply_rules(json, type, rules); end

  # Rules that apply to a class
  def class_rules; end

  # Generates a link to see an example of said rule
  def link(ref); end

  # Rules that apply to individual methods, and attributes
  def method_rules; end
end

# An internal class that is used to represent a rule for the linter.
class Danger::PluginLinter::Rule
  # @return [Rule] a new instance of Rule
  def initialize(modifier, ref, title, description, function); end

  # Returns the value of attribute description.
  def description; end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  def description=(_arg0); end

  # Returns the value of attribute function.
  def function; end

  # Sets the attribute function
  #
  # @param value the value to set the attribute function to.
  def function=(_arg0); end

  # Returns the value of attribute metadata.
  def metadata; end

  # Sets the attribute metadata
  #
  # @param value the value to set the attribute metadata to.
  def metadata=(_arg0); end

  # Returns the value of attribute modifier.
  def modifier; end

  # Sets the attribute modifier
  #
  # @param value the value to set the attribute modifier to.
  def modifier=(_arg0); end

  def object_applied_to; end

  # Returns the value of attribute ref.
  def ref; end

  # Sets the attribute ref
  #
  # @param value the value to set the attribute ref to.
  def ref=(_arg0); end

  # Returns the value of attribute title.
  def title; end

  # Sets the attribute title
  #
  # @param value the value to set the attribute title to.
  def title=(_arg0); end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end
end

class Danger::PluginParser
  # @return [PluginParser] a new instance of PluginParser
  def initialize(paths, verbose = T.unsafe(nil)); end

  def attribute_parser(gem_path, attribute); end
  def classes_in_file; end
  def method_params(method); end
  def method_parser(gem_path, meth); end
  def method_return_string(meth); end
  def parse; end
  def plugins_from_classes(classes); end

  # Returns the value of attribute registry.
  def registry; end

  # Sets the attribute registry
  #
  # @param value the value to set the attribute registry to.
  def registry=(_arg0); end

  def setup_yard(verbose); end
  def to_h(classes); end
  def to_json; end
  def to_json_string; end
end

class Danger::PluginReadme < ::CLAide::Command::Plugins
  # @return [PluginReadme] a new instance of PluginReadme
  def initialize(argv); end

  # Returns the value of attribute cork.
  def cork; end

  # Sets the attribute cork
  #
  # @param value the value to set the attribute cork to.
  def cork=(_arg0); end

  # Returns the value of attribute json.
  def json; end

  # Sets the attribute json
  #
  # @param value the value to set the attribute json to.
  def json=(_arg0); end

  # Returns the value of attribute markdown.
  def markdown; end

  # Sets the attribute markdown
  #
  # @param value the value to set the attribute markdown to.
  def markdown=(_arg0); end

  def run; end
end

class Danger::PrySetup
  # @return [PrySetup] a new instance of PrySetup
  def initialize(cork); end

  def setup_pry(dangerfile_path, command); end

  private

  # Returns the value of attribute cork.
  def cork; end

  def validate_pry_available(command); end
end

Danger::PrySetup::DANGERFILE_COPY = T.let(T.unsafe(nil), String)

class Danger::PullRequestFinder
  # @return [PullRequestFinder] a new instance of PullRequestFinder
  def initialize(specific_pull_request_id, repo_slug = T.unsafe(nil), remote: T.unsafe(nil), git_logs: T.unsafe(nil), remote_url: T.unsafe(nil)); end

  def call(env: T.unsafe(nil)); end

  private

  def api_url; end

  # @return [Boolean]
  def both_present?; end

  def client(env); end

  # @return [String] Log line of most recent merged Pull Request
  def find_pull_request(env); end

  def find_remote_pull_request(env); end
  def find_scm_provider(remote_url); end
  def generate_remote_pull_request(remote_pull_request); end

  # Returns the value of attribute git_logs.
  def git_logs; end

  # @return [String] Log line of format: "Merge pull request #42"
  def most_recent_merged_pull_request; end

  # @return [String] Log line of format: "description (#42)"
  def most_recent_squash_and_merged_pull_request; end

  # @return [Boolean]
  def only_merged_pull_request_present?; end

  # @return [Boolean]
  def only_squash_and_merged_pull_request_present?; end

  def pick_the_most_recent_one_from_two_matches; end

  # @return [String] "#42"
  def pull_request_ref; end

  def raise_pull_request_not_found!(pull_request); end

  # Returns the value of attribute remote.
  def remote; end

  # Returns the value of attribute remote_url.
  def remote_url; end

  # Returns the value of attribute repo_slug.
  def repo_slug; end

  # Returns the value of attribute specific_pull_request_id.
  def specific_pull_request_id; end

  def to_boolean(maybe_string); end
end

class Danger::RemotePullRequest
  # @return [RemotePullRequest] a new instance of RemotePullRequest
  def initialize(pull_request_id, head, base); end

  # Returns the value of attribute base.
  def base; end

  # Returns the value of attribute head.
  def head; end

  # Returns the value of attribute pull_request_id.
  def pull_request_id; end

  # Returns the value of attribute sha.
  def sha; end

  # @return [Boolean]
  def valid?; end
end

class Danger::RepoInfo
  # @return [RepoInfo] a new instance of RepoInfo
  def initialize(slug, id); end

  # Returns the value of attribute id.
  def id; end

  # Returns the value of attribute slug.
  def slug; end
end

module Danger::RequestSources; end

class Danger::RequestSources::BitbucketCloud < ::Danger::RequestSources::RequestSource
  include ::Danger::Helpers::CommentsParsingHelper
  include ::Danger::Helpers::CommentsHelper

  # @return [BitbucketCloud] a new instance of BitbucketCloud
  def initialize(ci_source, environment); end

  def delete_old_comments(danger_id: T.unsafe(nil)); end
  def fetch_details; end
  def host; end
  def organisation; end

  # Returns the value of attribute pr_json.
  def pr_json; end

  # Sets the attribute pr_json
  #
  # @param value the value to set the attribute pr_json to.
  def pr_json=(_arg0); end

  def scm; end
  def setup_danger_branches; end
  def update_inline_comments_for_kind!(kind, messages, danger_id: T.unsafe(nil)); end
  def update_pr_by_line!(message_groups:, danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end

  # @return [Boolean]
  def validates_as_api_source?; end

  # @return [Boolean]
  def validates_as_ci?; end

  class << self
    def env_vars; end
    def optional_env_vars; end
  end
end

class Danger::RequestSources::BitbucketCloudAPI
  # @return [BitbucketCloudAPI] a new instance of BitbucketCloudAPI
  def initialize(repo_slug, pull_request_id, branch_name, environment); end

  # Returns the value of attribute access_token.
  def access_token; end

  # Sets the attribute access_token
  #
  # @param value the value to set the attribute access_token to.
  def access_token=(_arg0); end

  # @return [Boolean]
  def credentials_given?; end

  def delete_comment(id); end
  def fetch_comments; end
  def fetch_pr_json; end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  def initialize_my_uuid(uuid); end
  def inspect; end

  # Returns the value of attribute my_uuid.
  def my_uuid; end

  def post_comment(text, file: T.unsafe(nil), line: T.unsafe(nil)); end

  # Returns the value of attribute project.
  def project; end

  # Sets the attribute project
  #
  # @param value the value to set the attribute project to.
  def project=(_arg0); end

  def pull_request(*_arg0); end

  # Returns the value of attribute pull_request_id.
  def pull_request_id; end

  # Sets the attribute pull_request_id
  #
  # @param value the value to set the attribute pull_request_id to.
  def pull_request_id=(_arg0); end

  # Returns the value of attribute slug.
  def slug; end

  # Sets the attribute slug
  #
  # @param value the value to set the attribute slug to.
  def slug=(_arg0); end

  private

  def base_url(version); end
  def credentials_not_available; end
  def delete(uri); end
  def error_fetching_json(url, status_code); end
  def fetch_access_token(environment); end
  def fetch_json(uri); end
  def fetch_pr_from_branch(branch_name); end
  def post(uri, body); end
  def pr_api_endpoint; end
  def prs_api_url(branch_name); end
end

class Danger::RequestSources::BitbucketServer < ::Danger::RequestSources::RequestSource
  include ::Danger::Helpers::CommentsParsingHelper
  include ::Danger::Helpers::CommentsHelper

  # @return [BitbucketServer] a new instance of BitbucketServer
  def initialize(ci_source, environment); end

  def added_lines(file); end
  def delete_old_comments(danger_id: T.unsafe(nil)); end

  # Returns the value of attribute dismiss_out_of_range_messages.
  def dismiss_out_of_range_messages; end

  # Sets the attribute dismiss_out_of_range_messages
  #
  # @param value the value to set the attribute dismiss_out_of_range_messages to.
  def dismiss_out_of_range_messages=(_arg0); end

  def fetch_details; end
  def file_diff(file); end

  # @return [Boolean]
  def find_position_in_diff?(file, line); end

  def host; end
  def inline_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end
  def main_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end
  def organisation; end
  def pr_diff; end

  # Returns the value of attribute pr_json.
  def pr_json; end

  # Sets the attribute pr_json
  #
  # @param value the value to set the attribute pr_json to.
  def pr_json=(_arg0); end

  def scm; end
  def setup_danger_branches; end
  def update_pr_build_status(status, build_job_link, description); end
  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end

  # @return [Boolean]
  def validates_as_api_source?; end

  # @return [Boolean]
  def validates_as_ci?; end

  class << self
    def env_vars; end
    def optional_env_vars; end
  end
end

class Danger::RequestSources::BitbucketServerAPI
  # @return [BitbucketServerAPI] a new instance of BitbucketServerAPI
  def initialize(project, slug, pull_request_id, environment); end

  # @return [Boolean]
  def credentials_given?; end

  def delete_comment(id, version); end
  def fetch_last_comments; end
  def fetch_pr_diff; end
  def fetch_pr_json; end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  def inspect; end

  # Returns the value of attribute key.
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  def key=(_arg0); end

  def post_comment(text); end

  # Returns the value of attribute pr_api_endpoint.
  def pr_api_endpoint; end

  # Sets the attribute pr_api_endpoint
  #
  # @param value the value to set the attribute pr_api_endpoint to.
  def pr_api_endpoint=(_arg0); end

  # Returns the value of attribute project.
  def project; end

  # Sets the attribute project
  #
  # @param value the value to set the attribute project to.
  def project=(_arg0); end

  def pull_request(*_arg0); end
  def update_pr_build_status(status, changeset, build_job_link, description); end

  # Returns the value of attribute verify_ssl.
  def verify_ssl; end

  # Sets the attribute verify_ssl
  #
  # @param value the value to set the attribute verify_ssl to.
  def verify_ssl=(_arg0); end

  private

  def build_status_body(status, build_job_link, description); end
  def delete(uri); end
  def fetch_json(uri); end
  def http(uri); end
  def post(uri, body); end
  def use_ssl; end
end

# Provides ability for Danger to interact with Atlassian's Code Insights API in order to provide code quality
# reports along with inline comments for specific lines in specific files.
#  See https://developer.atlassian.com/server/bitbucket/how-tos/code-insights/ for more details.
#
# Currently this functionality is implemented only for Bitbucket Server request source.
class Danger::RequestSources::CodeInsightsAPI
  # @return [CodeInsightsAPI] a new instance of CodeInsightsAPI
  def initialize(project, slug, environment); end

  def annotation_endpoint_at_commit(commit); end
  def delete_report(commit); end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  def inspect; end

  # Returns the value of attribute logo_url.
  def logo_url; end

  # Sets the attribute logo_url
  #
  # @param value the value to set the attribute logo_url to.
  def logo_url=(_arg0); end

  # Returns the value of attribute password.
  def password; end

  # Sets the attribute password
  #
  # @param value the value to set the attribute password to.
  def password=(_arg0); end

  def post_annotations(commit, inline_warnings, inline_errors, inline_messages); end
  def put_report(commit, inline_errors_count); end

  # @return [Boolean]
  def ready?; end

  # Returns the value of attribute report_description.
  def report_description; end

  # Sets the attribute report_description
  #
  # @param value the value to set the attribute report_description to.
  def report_description=(_arg0); end

  def report_endpoint_at_commit(commit); end

  # Returns the value of attribute report_key.
  def report_key; end

  # Sets the attribute report_key
  #
  # @param value the value to set the attribute report_key to.
  def report_key=(_arg0); end

  # Returns the value of attribute report_title.
  def report_title; end

  # Sets the attribute report_title
  #
  # @param value the value to set the attribute report_title to.
  def report_title=(_arg0); end

  def send_report(commit, inline_warnings, inline_errors, inline_messages); end
  def use_ssl; end

  # Returns the value of attribute username.
  def username; end

  # Sets the attribute username
  #
  # @param value the value to set the attribute username to.
  def username=(_arg0); end

  def violation_hash_with_severity(violation, severity); end
end

class Danger::RequestSources::GitHub < ::Danger::RequestSources::RequestSource
  include ::Danger::Helpers::CommentsParsingHelper
  include ::Danger::Helpers::CommentsHelper

  # @return [GitHub] a new instance of GitHub
  def initialize(ci_source, environment); end

  # Returns the value of attribute api_url.
  def api_url; end

  # Sets the attribute api_url
  #
  # @param value the value to set the attribute api_url to.
  def api_url=(_arg0); end

  def client; end

  # Get rid of the previously posted comment, to only have the latest one
  def delete_old_comments!(except: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  # Returns the value of attribute dismiss_out_of_range_messages.
  def dismiss_out_of_range_messages; end

  # Sets the attribute dismiss_out_of_range_messages
  #
  # @param value the value to set the attribute dismiss_out_of_range_messages to.
  def dismiss_out_of_range_messages=(_arg0); end

  def dismiss_out_of_range_messages_for(kind); end
  def fetch_details; end
  def fetch_issue_details(pr_json); end

  # @return [String] A URL to the specific file, ready to be downloaded
  def file_url(organisation: T.unsafe(nil), repository: T.unsafe(nil), branch: T.unsafe(nil), path: T.unsafe(nil)); end

  def find_position_in_diff(diff_lines, message, kind); end
  def get_pr_from_branch(repo_name, branch_name, owner); end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  def ignored_violations_from_pr; end
  def issue_comments; end

  # Returns the value of attribute issue_json.
  def issue_json; end

  # Sets the attribute issue_json
  #
  # @param value the value to set the attribute issue_json to.
  def issue_json=(_arg0); end

  def markdown_link_to_message(message, hide_link); end
  def messages_are_equivalent(m1, m2); end

  # @return [String] The organisation name, is nil if it can't be detected
  def organisation; end

  # See the tests for examples of data coming in looks like
  def parse_message_from_row(row); end

  def pr_diff; end

  # Returns the value of attribute pr_json.
  def pr_json; end

  # Sets the attribute pr_json
  #
  # @param value the value to set the attribute pr_json to.
  def pr_json=(_arg0); end

  def review; end
  def scm; end
  def setup_danger_branches; end
  def submit_inline_comments!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), previous_violations: T.unsafe(nil), danger_id: T.unsafe(nil)); end
  def submit_inline_comments_for_kind!(kind, messages, diff_lines, danger_comments, previous_violations, danger_id: T.unsafe(nil)); end
  def submit_pull_request_status!(warnings: T.unsafe(nil), errors: T.unsafe(nil), details_url: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  # Returns the value of attribute support_tokenless_auth.
  def support_tokenless_auth; end

  # Sets the attribute support_tokenless_auth
  #
  # @param value the value to set the attribute support_tokenless_auth to.
  def support_tokenless_auth=(_arg0); end

  # Sending data to GitHub
  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end

  # Returns the value of attribute use_local_git.
  def use_local_git; end

  # Sets the attribute use_local_git
  #
  # @param value the value to set the attribute use_local_git to.
  def use_local_git=(_arg0); end

  # @return [Boolean]
  def validates_as_api_source?; end

  # @return [Boolean]
  def validates_as_ci?; end

  # Returns the value of attribute verify_ssl.
  def verify_ssl; end

  # Sets the attribute verify_ssl
  #
  # @param value the value to set the attribute verify_ssl to.
  def verify_ssl=(_arg0); end

  private

  def inline_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end
  def merge_violations(*violation_groups); end
  def regular_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end

  # @return [Boolean]
  def valid_access_token?; end

  # @return [Boolean]
  def valid_bearer_token?; end

  class << self
    def env_vars; end
    def optional_env_vars; end
  end
end

module Danger::RequestSources::GitHubSource; end

class Danger::RequestSources::GitHubSource::Review
  include ::Danger::Helpers::CommentsParsingHelper
  include ::Danger::Helpers::CommentsHelper

  # @return [Review] a new instance of Review
  def initialize(client, ci_source, review_json = T.unsafe(nil)); end

  # Returns the value of attribute body.
  def body; end

  def fail(message, sticky = T.unsafe(nil), file = T.unsafe(nil), line = T.unsafe(nil)); end

  # @return [Boolean]
  def generated_by_danger?(danger_id = T.unsafe(nil)); end

  # Returns the value of attribute id.
  def id; end

  def markdown(message, file = T.unsafe(nil), line = T.unsafe(nil)); end
  def message(message, sticky = T.unsafe(nil), file = T.unsafe(nil), line = T.unsafe(nil)); end

  # Returns the value of attribute review_json.
  def review_json; end

  # Starts the new review process
  def start; end

  # Returns the value of attribute status.
  def status; end

  # Submits the prepared review
  def submit; end

  def warn(message, sticky = T.unsafe(nil), file = T.unsafe(nil), line = T.unsafe(nil)); end

  private

  def generate_body(danger_id: T.unsafe(nil)); end

  # The only reason to request changes for the PR is to have errors from Danger
  # otherwise let's just notify user and we're done
  def generate_event(violations); end

  def generate_general_violations; end
end

# @see https://developer.github.com/v3/pulls/reviews/ for all possible events
Danger::RequestSources::GitHubSource::Review::EVENT_APPROVE = T.let(T.unsafe(nil), String)

Danger::RequestSources::GitHubSource::Review::EVENT_COMMENT = T.let(T.unsafe(nil), String)
Danger::RequestSources::GitHubSource::Review::EVENT_REQUEST_CHANGES = T.let(T.unsafe(nil), String)

# Current review status, if the review has not been submitted yet -> STATUS_PENDING
Danger::RequestSources::GitHubSource::Review::STATUS_APPROVED = T.let(T.unsafe(nil), String)

Danger::RequestSources::GitHubSource::Review::STATUS_COMMENTED = T.let(T.unsafe(nil), String)
Danger::RequestSources::GitHubSource::Review::STATUS_PENDING = T.let(T.unsafe(nil), String)
Danger::RequestSources::GitHubSource::Review::STATUS_REQUESTED_CHANGES = T.let(T.unsafe(nil), String)

class Danger::RequestSources::GitHubSource::ReviewResolver
  class << self
    # @return [Boolean]
    def same_body?(body1, body2); end

    # @return [Boolean]
    def should_submit?(review, body); end
  end
end

class Danger::RequestSources::GitHubSource::ReviewUnsupported
  # @return [ReviewUnsupported] a new instance of ReviewUnsupported
  def initialize; end

  # Returns the value of attribute body.
  def body; end

  def fail(message, sticky = T.unsafe(nil), file = T.unsafe(nil), line = T.unsafe(nil)); end

  # Returns the value of attribute id.
  def id; end

  def markdown(message, file = T.unsafe(nil), line = T.unsafe(nil)); end
  def message(message, sticky = T.unsafe(nil), file = T.unsafe(nil), line = T.unsafe(nil)); end

  # Returns the value of attribute review_json.
  def review_json; end

  def start; end

  # Returns the value of attribute status.
  def status; end

  def submit; end
  def warn(message, sticky = T.unsafe(nil), file = T.unsafe(nil), line = T.unsafe(nil)); end
end

class Danger::RequestSources::GitLab < ::Danger::RequestSources::RequestSource
  include ::Danger::Helpers::CommentsParsingHelper
  include ::Danger::Helpers::CommentsHelper

  # @return [GitLab] a new instance of GitLab
  def initialize(ci_source, environment); end

  def base_commit; end
  def client; end

  # Returns the value of attribute commits_json.
  def commits_json; end

  # Sets the attribute commits_json
  #
  # @param value the value to set the attribute commits_json to.
  def commits_json=(_arg0); end

  def delete_old_comments!(except: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  # Returns the value of attribute dismiss_out_of_range_messages.
  def dismiss_out_of_range_messages; end

  # Sets the attribute dismiss_out_of_range_messages
  #
  # @param value the value to set the attribute dismiss_out_of_range_messages to.
  def dismiss_out_of_range_messages=(_arg0); end

  def dismiss_out_of_range_messages_for(kind); end

  # Returns the value of attribute endpoint.
  def endpoint; end

  # Sets the attribute endpoint
  #
  # @param value the value to set the attribute endpoint to.
  def endpoint=(_arg0); end

  def fetch_details; end

  # @return [String] A URL to the specific file, ready to be downloaded
  def file_url(organisation: T.unsafe(nil), repository: T.unsafe(nil), branch: T.unsafe(nil), path: T.unsafe(nil)); end

  def find_old_position_in_diff(changes, message); end
  def generate_addition_lines(diff); end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  def ignored_violations_from_pr; end
  def inline_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end
  def is_out_of_range(changes, message); end
  def markdown_link_to_message(message, _); end
  def merge_violations(*violation_groups); end
  def mr_changed_paths; end
  def mr_changes; end
  def mr_closes_issues; end
  def mr_comments; end
  def mr_diff; end
  def mr_discussions; end

  # Returns the value of attribute mr_json.
  def mr_json; end

  # Sets the attribute mr_json
  #
  # @param value the value to set the attribute mr_json to.
  def mr_json=(_arg0); end

  # @return [String] The organisation name, is nil if it can't be detected
  def organisation; end

  def regular_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end
  def scm; end
  def setup_danger_branches; end
  def submit_inline_comments!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), previous_violations: T.unsafe(nil), danger_id: T.unsafe(nil)); end
  def submit_inline_comments_for_kind!(kind, messages, diff_lines, danger_comments, previous_violations, danger_id: T.unsafe(nil)); end
  def supports_inline_comments; end
  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
  def update_pull_request_with_inline_comments!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
  def update_pull_request_without_inline_comments!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end

  # @return [Boolean]
  def validates_as_api_source?; end

  # @return [Boolean]
  def validates_as_ci?; end

  class << self
    def env_vars; end
    def optional_env_vars; end
  end
end

Danger::RequestSources::GitLab::FIRST_GITLAB_GEM_WITH_VERSION_CHECK = T.let(T.unsafe(nil), Gem::Version)
Danger::RequestSources::GitLab::FIRST_VERSION_WITH_INLINE_COMMENTS = T.let(T.unsafe(nil), Gem::Version)

class Danger::RequestSources::LocalOnly < ::Danger::RequestSources::RequestSource
  include ::Danger::Helpers::CommentsParsingHelper
  include ::Danger::Helpers::CommentsHelper

  # @return [LocalOnly] a new instance of LocalOnly
  def initialize(ci_source, _environment); end

  # Returns the value of attribute commits_json.
  def commits_json; end

  # Sets the attribute commits_json
  #
  # @param value the value to set the attribute commits_json to.
  def commits_json=(_arg0); end

  def fetch_details; end

  # Returns the value of attribute mr_json.
  def mr_json; end

  # Sets the attribute mr_json
  #
  # @param value the value to set the attribute mr_json to.
  def mr_json=(_arg0); end

  # @return [String] The organisation name, is nil if it can't be detected
  def organisation; end

  def scm; end
  def setup_danger_branches; end
  def update_pull_request!(_hash_needed); end

  # @return [Boolean]
  def validates_as_api_source?; end

  # @return [Boolean]
  def validates_as_ci?; end

  class << self
    def env_vars; end
  end
end

class Danger::RequestSources::RequestSource
  # @return [RequestSource] a new instance of RequestSource
  def initialize(_ci_source, _environment); end

  # Returns the value of attribute ci_source.
  def ci_source; end

  # Sets the attribute ci_source
  #
  # @param value the value to set the attribute ci_source to.
  def ci_source=(_arg0); end

  def fetch_details; end
  def file_url(_organisation: T.unsafe(nil), _repository: T.unsafe(nil), _branch: T.unsafe(nil), _path: T.unsafe(nil)); end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  # Returns the value of attribute ignored_violations.
  def ignored_violations; end

  # Sets the attribute ignored_violations
  #
  # @param value the value to set the attribute ignored_violations to.
  def ignored_violations=(_arg0); end

  def inspect; end
  def organisation; end

  # Returns the value of attribute scm.
  def scm; end

  # Sets the attribute scm
  #
  # @param value the value to set the attribute scm to.
  def scm=(_arg0); end

  def setup_danger_branches; end
  def update_build_status(status); end
  def update_pull_request!(_warnings: T.unsafe(nil), _errors: T.unsafe(nil), _messages: T.unsafe(nil), _markdowns: T.unsafe(nil)); end

  # @return [Boolean]
  def validates_as_api_source?; end

  # @return [Boolean] whether scm.origins is a valid git repository or not
  def validates_as_ci?; end

  class << self
    def available_request_sources; end
    def available_source_names_and_envs; end
    def env_vars; end

    # @private
    def inherited(child_class); end

    def optional_env_vars; end
    def source_name; end
  end
end

Danger::RequestSources::RequestSource::DANGER_REPO_NAME = T.let(T.unsafe(nil), String)

class Danger::RequestSources::VSTS < ::Danger::RequestSources::RequestSource
  include ::Danger::Helpers::CommentsParsingHelper
  include ::Danger::Helpers::CommentsHelper

  # @return [VSTS] a new instance of VSTS
  def initialize(ci_source, environment); end

  def client; end
  def fetch_details; end
  def host; end
  def messages_are_equivalent(m1, m2); end
  def organisation; end
  def post_new_comment(comment); end

  # Returns the value of attribute pr_json.
  def pr_json; end

  # Sets the attribute pr_json
  #
  # @param value the value to set the attribute pr_json to.
  def pr_json=(_arg0); end

  def scm; end
  def setup_danger_branches; end
  def submit_inline_comments!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), previous_violations: T.unsafe(nil), danger_id: T.unsafe(nil)); end
  def submit_inline_comments_for_kind!(kind, messages, danger_threads, previous_violations, danger_id: T.unsafe(nil)); end
  def update_old_comment(new_comment, danger_id: T.unsafe(nil)); end
  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end

  # @return [Boolean]
  def validates_as_api_source?; end

  # @return [Boolean]
  def validates_as_ci?; end

  private

  def inline_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end
  def merge_violations(*violation_groups); end
  def regular_violations_group(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil)); end

  class << self
    def env_vars; end
    def optional_env_vars; end
  end
end

class Danger::RequestSources::VSTSAPI
  # @return [VSTSAPI] a new instance of VSTSAPI
  def initialize(_project, slug, pull_request_id, environment); end

  # @return [Boolean]
  def credentials_given?; end

  def fetch_last_comments; end
  def fetch_pr_json; end

  # Returns the value of attribute host.
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  def inspect; end

  # Returns the value of attribute min_api_version_for_comments.
  def min_api_version_for_comments; end

  # Sets the attribute min_api_version_for_comments
  #
  # @param value the value to set the attribute min_api_version_for_comments to.
  def min_api_version_for_comments=(_arg0); end

  def post_comment(text); end
  def post_inline_comment(text, file, line); end

  # Returns the value of attribute pr_api_endpoint.
  def pr_api_endpoint; end

  # Sets the attribute pr_api_endpoint
  #
  # @param value the value to set the attribute pr_api_endpoint to.
  def pr_api_endpoint=(_arg0); end

  # @return [Boolean]
  def supports_comments?; end

  def update_comment(thread, id, new_comment); end

  private

  def fetch_json(uri); end
  def patch(uri, body); end
  def post(uri, body); end
  def use_ssl; end
end

class Danger::Runner < ::CLAide::Command
  # @return [Runner] a new instance of Runner
  def initialize(argv); end

  # Returns the value of attribute cork.
  def cork; end

  # Sets the attribute cork
  #
  # @param value the value to set the attribute cork to.
  def cork=(_arg0); end

  def run; end
  def validate!; end

  private

  def adjust_colored2_output(argv); end

  class << self
    def options; end
  end
end

# ### CI Setup
#
# Install dependencies and add a danger step to your screwdriver.yaml:
#
# ```yml
# jobs:
#   danger:
#     requires: [~pr, ~commit]
#     steps:
#       - setup: bundle install --path vendor
#       - danger: bundle exec danger
#     secrets:
#       - DANGER_GITHUB_API_TOKEN
# ```
#
# ### Token Setup
#
# Add the `DANGER_GITHUB_API_TOKEN` to your pipeline env as a
# [build secret](https://docs.screwdriver.cd/user-guide/configuration/secrets)
class Danger::Screwdriver < ::Danger::CI
  # @return [Screwdriver] a new instance of Screwdriver
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# For Semaphore you will want to go to the settings page of the project. Inside "Build Settings"
# you should add `bundle exec danger` to the Setup thread. Note that Semaphore only provides
# the build environment variables necessary for Danger on PRs across forks.
#
# ### Token Setup
#
# You can add your `DANGER_GITHUB_API_TOKEN` inside the "Environment Variables" section in the settings.
class Danger::Semaphore < ::Danger::CI
  # @return [Semaphore] a new instance of Semaphore
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

class Danger::Staging < ::Danger::Runner
  # @return [Staging] a new instance of Staging
  def initialize(argv); end

  def run; end
  def validate!; end

  class << self
    def options; end
  end
end

# ### CI Setup
#
# You want to add `bundle exec danger` to your `build.sh` file to run  Danger at the
# end of your build.
#
# ### Token Setup
#
# As this is self-hosted, you will need to add the `DANGER_GITHUB_API_TOKEN` to your build user's ENV. The alternative
# is to pass in the token as a prefix to the command `DANGER_GITHUB_API_TOKEN="123" bundle exec danger`.
class Danger::Surf < ::Danger::CI
  # @return [Surf] a new instance of Surf
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

class Danger::Systems < ::Danger::Runner; end

# ### CI Setup
#
# You need to go to your project settings. Then depending on the type of your build settings, you may need
# to add a new build step for Danger. You want to be able to run the command `bundle exec danger`, so
# the "Simple Command Runner" should be all you need to do that.
#
# ### Token + Environment Setup
#
# #### GitHub
#
# As this is self-hosted, you will need to add the `DANGER_GITHUB_API_TOKEN` to your build user's ENV. The alternative
# is to pass in the token as a prefix to the command `DANGER_GITHUB_API_TOKEN="123" bundle exec danger`.
#
# However, you will need to find a way to add the environment vars: `GITHUB_REPO_SLUG`, `GITHUB_PULL_REQUEST_ID` and
# `GITHUB_REPO_URL`. These are not added by default. You can manually add `GITHUB_REPO_SLUG` and `GITHUB_REPO_URL`
#  as build parameters or by exporting them inside your Simple Command Runner.
#
# As for `GITHUB_PULL_REQUEST_ID`, TeamCity provides the `%teamcity.build.branch%` variable which is in the format
# `PR_NUMBER/merge`. You can slice the Pull Request ID out by doing the following:
#
# ```sh
# branch="%teamcity.build.branch%"
# export GITHUB_PULL_REQUEST_ID=(${branch//\// })
# ```
#
# Or if you are using the pull request feature you can set an environment parameter called `GITHUB_PULL_REQUEST_ID`
# to the value of: `%teamcity.pullRequest.number`
#
# #### GitLab
#
# As this is self-hosted, you will need to add the `DANGER_GITLAB_API_TOKEN` to your build user's ENV. The alternative
# is to pass in the token as a prefix to the command `DANGER_GITLAB_API_TOKEN="123" bundle exec danger`.
#
# However, you will need to find a way to add the environment vars: `GITLAB_REPO_SLUG`, `GITLAB_PULL_REQUEST_ID` and
# `GITLAB_REPO_URL`. These are not added by default. You could do this via the GitLab API potentially.
#
# We would love some advice on improving this setup.
#
# #### BitBucket Cloud
#
# You will need to add the following environment variables as build parameters or by exporting them inside your
# Simple Command Runner.
#
#
# - `BITBUCKET_REPO_SLUG`
# - `BITBUCKET_REPO_URL`
#
# - `DANGER_BITBUCKETCLOUD_USERNAME`
# - `DANGER_BITBUCKETCLOUD_PASSWORD`
#
# or
#
# - `DANGER_BITBUCKETCLOUD_OAUTH_KEY`
# - `DANGER_BITBUCKETCLOUD_OAUTH_SECRET`
#
# You will also need to set the `BITBUCKET_BRANCH_NAME` environment variable.
# TeamCity provides `%teamcity.build.branch%`, which you can use at the top of your Simple Command Runner:
#
# ```sh
# export BITBUCKET_BRANCH_NAME="%teamcity.build.branch%"
# ```
#
# #### BitBucket Server
#
# You will need to add the following environment variables as build parameters or by exporting them inside your
# Simple Command Runner.
#
# - `DANGER_BITBUCKETSERVER_USERNAME`
# - `DANGER_BITBUCKETSERVER_PASSWORD`
# - `DANGER_BITBUCKETSERVER_HOST`
# - `BITBUCKETSERVER_REPO_SLUG`
# - `BITBUCKETSERVER_PULL_REQUEST_ID`
# - `BITBUCKETSERVER_REPO_URL`
class Danger::TeamCity < ::Danger::CI
  # @return [TeamCity] a new instance of TeamCity
  def initialize(env); end

  def supported_request_sources; end

  private

  # This is a little hacky, because Bitbucket doesn't provide us a PR id
  def bitbucket_pr_from_env(env); end

  def extract_bitbucket_server_variables!(env); end
  def extract_bitbucket_variables!(env); end
  def extract_github_variables!(env); end
  def extract_gitlab_variables!(env); end

  class << self
    # @return [Boolean]
    def validates_as_bitbucket_cloud_pr?(env); end

    # @return [Boolean]
    def validates_as_bitbucket_server_pr?(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_github_pr?(env); end

    # @return [Boolean]
    def validates_as_gitlab_pr?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
# You need to edit your `.travis.yml` to include `bundle exec danger`. If you already have
# a `script:` section then we recommend adding this command at the end of the script step: `- bundle exec danger`.
#
#  Otherwise, add a `before_script` step to the root of the `.travis.yml` with `bundle exec danger`
#
#  ```ruby
#    before_script:
#      - bundle exec danger
#  ```
#
# Adding this to your `.travis.yml` allows Danger to fail your build, both on the TravisCI website and within your Pull Request.
# With that set up, you can edit your job to add `bundle exec danger` at the build action.
#
# _Note:_ Travis CI defaults to using an older version of Ruby, so you may need to add `rvm: 2.0.0` to the root your `.travis.yml`.
#
# ### Token Setup
#
# You need to add the `DANGER_GITHUB_API_TOKEN` environment variable, to do this,
# go to your repo's settings, which should look like: `https://travis-ci.org/[user]/[repo]/settings`.
#
# If you have an open source project, you should ensure "Display value in build log" enabled, so that PRs from forks work.
class Danger::Travis < ::Danger::CI
  # @return [Travis] a new instance of Travis
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

Danger::VERSION = T.let(T.unsafe(nil), String)

# ### CI Setup
#
# You need to go to your project's build definition. Then add a "Command Line" Task with the "Tool" field set to  "bundle"
# and the "Arguments" field set to "exec danger".
#
# ### Token Setup
#
# #### GitHub
#
# You need to add the `DANGER_GITHUB_API_TOKEN` environment variable, to do this, go to your build definition's variables tab.
#
# Make sure that `DANGER_GITHUB_API_TOKEN` is not set to secret since vsts does not expose secret variables while building.
#
# #### VSTS
#
# You need to add the `DANGER_VSTS_API_TOKEN` and `DANGER_VSTS_HOST` environment variable, to do this,
# go to your build definition's variables tab. The `DANGER_VSTS_API_TOKEN` is your vsts personal access token.
# Instructions for creating a personal access token can be found [here](https://www.visualstudio.com/en-us/docs/setup-admin/team-services/use-personal-access-tokens-to-authenticate).
# For the `DANGER_VSTS_HOST` variable the suggested value is `$(System.TeamFoundationCollectionUri)$(System.TeamProject)`
# which will automatically get your vsts domain and your project name needed for the vsts api.
#
# Make sure that `DANGER_VSTS_API_TOKEN` is not set to secret since vsts does not expose secret variables while building.
class Danger::VSTS < ::Danger::CI
  # @return [VSTS] a new instance of VSTS
  def initialize(env); end

  def supported_request_sources; end

  class << self
    def github_slug(env); end

    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end

    def vsts_slug(env); end
  end
end

class Danger::Violation < ::Danger::BaseMessage
  # @raise [ArgumentError]
  # @return [Violation] a new instance of Violation
  def initialize(message, sticky, file = T.unsafe(nil), line = T.unsafe(nil), type: T.unsafe(nil)); end

  def <=>(other); end
  def ==(other); end
  def hash; end

  # Returns the value of attribute sticky.
  def sticky; end

  # Sets the attribute sticky
  #
  # @param value the value to set the attribute sticky to.
  def sticky=(_arg0); end

  def to_s; end
end

Danger::Violation::VALID_TYPES = T.let(T.unsafe(nil), Array)

# ### CI Setup
#
# In order to work with Xcode Cloud and Danger, you will need to add `bundle exec danger` to
# the `ci_scripts/ci_post_xcodebuild.sh` (Xcode Cloud's expected filename for a post-action build script).
# More details and documentation on Xcode Cloud configuration can be found [here](https://developer.apple.com/documentation/xcode/writing-custom-build-scripts).
#
# ### Token Setup
#
# You will need to add the `DANGER_GITHUB_API_TOKEN` to your build environment.
# If running on GitHub Enterprise, make sure you also set the expected values for
# both `DANGER_GITHUB_API_HOST` and `DANGER_GITHUB_HOST`.
class Danger::XcodeCloud < ::Danger::CI
  # @return [XcodeCloud] a new instance of XcodeCloud
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# ### CI Setup
#
# If you're bold enough to use Xcode Bots. You will need to use [Buildasaur](https://github.com/czechboy0/Buildasaur)
# in order to work with Danger. This will set up your build environment for you, as the name of the bot contains all
# of the environment variables that Danger needs to work.
#
# With Buildasaur set up, you can edit your job to add `bundle exec danger` as a post-action build script.
#
# ### Token Setup
#
# As this is self-hosted, you will need to add the `DANGER_GITHUB_API_TOKEN` to your build user's ENV. The alternative
# is to pass in the token as a prefix to the command `DANGER_GITHUB_API_TOKEN="123" bundle exec danger`.`.
class Danger::XcodeServer < ::Danger::CI
  # @return [XcodeServer] a new instance of XcodeServer
  def initialize(env); end

  def supported_request_sources; end

  class << self
    # @return [Boolean]
    def validates_as_ci?(env); end

    # @return [Boolean]
    def validates_as_pr?(env); end
  end
end

# Find max_num_violations in lib/danger/comment_generators/github.md.erb.
class FindMaxNumViolations
  # @return [FindMaxNumViolations] a new instance of FindMaxNumViolations
  def initialize(violations); end

  def call; end

  private

  # Returns the value of attribute violations.
  def violations; end
end

# Save ~ 5000 for contents other than violations to avoid exceeded 65536 max comment length limit.
FindMaxNumViolations::LIMIT = T.let(T.unsafe(nil), Integer)

class GetIgnoredViolation
  # @return [GetIgnoredViolation] a new instance of GetIgnoredViolation
  def initialize(body); end

  def call; end

  private

  # Returns the value of attribute body.
  def body; end
end

GetIgnoredViolation::IGNORE_REGEXP = T.let(T.unsafe(nil), Regexp)

module Git
  def config(name = T.unsafe(nil), value = T.unsafe(nil)); end
  def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  class << self
    def bare(git_dir, options = T.unsafe(nil)); end
    def clone(repository_url, directory = T.unsafe(nil), options = T.unsafe(nil)); end
    def config; end
    def configure; end
    def export(repository, name, options = T.unsafe(nil)); end
    def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end
    def ls_remote(location = T.unsafe(nil), options = T.unsafe(nil)); end
    def open(working_dir, options = T.unsafe(nil)); end
  end
end

class Git::Base
  include ::Git::Base::Factory

  def initialize(options = T.unsafe(nil)); end

  def add(paths = T.unsafe(nil), **options); end
  def add_remote(name, url, opts = T.unsafe(nil)); end
  def add_tag(name, *options); end
  def apply(file); end
  def apply_mail(file); end
  def archive(treeish, file = T.unsafe(nil), opts = T.unsafe(nil)); end
  def cat_file(objectish); end
  def chdir; end
  def checkout(branch = T.unsafe(nil), opts = T.unsafe(nil)); end
  def checkout_file(version, file); end
  def checkout_index(opts = T.unsafe(nil)); end
  def clean(opts = T.unsafe(nil)); end
  def commit(message, opts = T.unsafe(nil)); end
  def commit_all(message, opts = T.unsafe(nil)); end
  def config(name = T.unsafe(nil), value = T.unsafe(nil), options = T.unsafe(nil)); end
  def current_branch; end
  def delete_tag(name); end
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def dir; end
  def each_conflict(&block); end
  def fetch(remote = T.unsafe(nil), opts = T.unsafe(nil)); end
  def gc; end
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def index; end
  def is_branch?(branch); end
  def is_local_branch?(branch); end
  def is_remote_branch?(branch); end
  def lib; end
  def ls_files(location = T.unsafe(nil)); end
  def ls_tree(objectish); end
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Use git-merge-base https://git-scm.com/docs/git-merge-base to
  # find as good common ancestors as possible for a merge
  def merge_base(commit1, commit2, *other_commits); end

  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil)); end
  def push(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end
  def read_tree(treeish, opts = T.unsafe(nil)); end
  def remotes; end
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end
  def remove_remote(name); end
  def repack; end
  def repo; end
  def repo_size; end
  def reset(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def reset_hard(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def revert(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def revparse(objectish); end
  def set_index(index_file, check = T.unsafe(nil)); end
  def set_remote_url(name, url); end
  def set_working(work_dir, check = T.unsafe(nil)); end
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end
  def tags; end
  def update_ref(branch, commit); end
  def with_index(new_index); end
  def with_temp_index(&blk); end
  def with_temp_working(&blk); end
  def with_working(work_dir); end
  def write_and_commit_tree(opts = T.unsafe(nil)); end
  def write_tree; end

  class << self
    def bare(git_dir, options = T.unsafe(nil)); end
    def clone(repository_url, directory, options = T.unsafe(nil)); end
    def config; end
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end
    def open(working_dir, options = T.unsafe(nil)); end

    private

    def normalize_index(options); end
    def normalize_paths(options, default_working_directory: T.unsafe(nil), default_repository: T.unsafe(nil), bare: T.unsafe(nil)); end
    def normalize_repository(options, default:, bare: T.unsafe(nil)); end
    def normalize_working_directory(options, default:, bare: T.unsafe(nil)); end
  end
end

Git::VERSION = T.let(T.unsafe(nil), String)

# Enhance the String class with a XML escaped character version of
# to_s.
class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Colored2
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  # @return [String] the plural form of self determined by count
  def danger_pluralize(count); end

  # @return [String] truncates string with ellipsis when exceeding the limit
  def danger_truncate(limit); end

  # @return [String] converts to underscored, lowercase form
  def danger_underscore; end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
