# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `claide` gem.
# Please instead update this file by running `bin/tapioca gem claide`.

# The mods of interest are {CLAide::ARGV}, {CLAide::Command}, and
# {CLAide::InformativeError}
module CLAide; end

# Provides support for ANSI Escape sequences
#
# For more information see:
#
# - http://ascii-table.com/ansi-escape-sequences.php
# - http://en.wikipedia.org/wiki/ANSI_escape_code
#
# This functionality has been inspired and derived from the following gems:
#
# - colored
# - colorize
class CLAide::ANSI
  extend ::CLAide::ANSI::Cursor
  extend ::CLAide::ANSI::Graphics

  class << self
    # @param key [Symbol] The key for which the code is needed.
    # @param map [Hash{Symbol => Fixnum}] A hash which associates each code to each key.
    # @raise If the key is not provided.
    # @raise If the key is not present in the map.
    # @return [Fixnum] The code of a key given the map.
    def code_for_key(key, map); end

    # original string. This method is intended to offer a central location
    # where to disable ANSI logic without needed to implement conditionals
    # across the code base of clients.
    #
    # @example
    #
    #   "example".ansi.yellow #=> "\e[33mexample\e[39m"
    #   ANSI.disabled = true
    #   "example".ansi.yellow #=> "example"
    # @return [Bool] Wether the string mixin should be disabled to return the
    def disabled; end

    # original string. This method is intended to offer a central location
    # where to disable ANSI logic without needed to implement conditionals
    # across the code base of clients.
    #
    # @example
    #
    #   "example".ansi.yellow #=> "\e[33mexample\e[39m"
    #   ANSI.disabled = true
    #   "example".ansi.yellow #=> "example"
    # @return [Bool] Wether the string mixin should be disabled to return the
    def disabled=(_arg0); end
  end
end

# @return [Hash{Symbol => Fixnum}] The colors codes by their English name.
CLAide::ANSI::COLORS = T.let(T.unsafe(nil), Hash)

# Provides support for generating escape sequences relative to the position
# of the cursor and to erase parts of text.
module CLAide::ANSI::Cursor
  class << self
    # @return [String] The escape sequence to erase the display.
    def erase_display; end

    # @return [String] The escape sequence to erase a line form the
    #   cursor position to then end.
    def erase_line; end

    # @param lines [Fixnum] The amount of lines the cursor should be moved to.
    #   Negative values indicate up direction and positive ones
    #   down direction.
    # @param columns [Fixnum] The amount of columns the cursor should be moved to.
    #   Negative values indicate left direction and positive ones
    #   right direction.
    # @return [String] The escape sequence to set the cursor at the
    #   given line.
    def move_cursor(lines, columns = T.unsafe(nil)); end

    # @return [String] The escape sequence to restore the cursor to the
    #   previously saved position. This sequence also clears all the
    #   output after the position.
    def restore_cursor_position; end

    # @return [String] The escape sequence to save the cursor position.
    def save_cursor_position; end

    # @param line [Fixnum] The line where to place the cursor.
    # @param column [Fixnum] The column where to place the cursor.
    # @return [String] The escape sequence to set the cursor at the
    #   given line.
    def set_cursor_position(line = T.unsafe(nil), column = T.unsafe(nil)); end
  end
end

# Return [String] The escape sequence for the default background color.
CLAide::ANSI::DEFAULT_BACKGROUND_COLOR = T.let(T.unsafe(nil), String)

# Return [String] The escape sequence for the default foreground color.
CLAide::ANSI::DEFAULT_FOREGROUND_COLOR = T.let(T.unsafe(nil), String)

# Provides support for generating escape sequences relative to the graphic
# mode.
module CLAide::ANSI::Graphics
  class << self
    # @param key [Symbol] The name of the color.
    # @return [String] The escape sequence for a background color.
    def background_color(key); end

    # @param color [Fixnum] The value of the color.
    # @return [String] The escape sequence for a background color using the
    #   xterm-256 format.
    def background_color_256(color); end

    # @param key [Symbol] The name of the color.
    # @return [String] The escape sequence for a foreground color.
    def foreground_color(key); end

    # @param color [Fixnum] The value of the color.
    # @return [String] The escape sequence for a foreground color using the
    #   xterm-256 format.
    def foreground_color_256(color); end

    # @param codes [Fixnum, Array<Fixnum>] The code(s).
    # @return [String] The escape sequence for a single or a list of codes.
    def graphics_mode(codes); end

    # @param key [Symbol] The name of the text attribute.
    # @return [String] The escape sequence for a text attribute.
    def text_attribute(key); end
  end
end

# Return [String] The escape sequence to reset the graphics.
CLAide::ANSI::RESET_SEQUENCE = T.let(T.unsafe(nil), String)

# Provides support to wrap strings in ANSI sequences according to the
# `ANSI.disabled` setting.
class CLAide::ANSI::StringEscaper < ::String
  # @param string [String] The string to wrap.
  # @return [StringEscaper] a new instance of StringEscaper
  def initialize(string); end

  # @param keys [Array<Symbol>] One or more keys corresponding to ANSI codes to apply to the
  #   string.
  # @return [StringEscaper]
  def apply(*keys); end

  def black; end
  def blink; end
  def blue; end
  def bold; end
  def cyan; end
  def green; end
  def hidden; end
  def magenta; end
  def on_black; end
  def on_blue; end
  def on_cyan; end
  def on_green; end
  def on_magenta; end
  def on_red; end
  def on_white; end
  def on_yellow; end
  def red; end
  def reverse; end
  def underline; end
  def white; end

  # @return [StringEscaper] Wraps a string in the given ANSI sequences,
  #   taking care of handling existing sequences for the same
  #   family of attributes (i.e. attributes terminated by the
  #   same sequence).
  def wrap_in_ansi_sequence(open, close); end

  def yellow; end
end

# @return [Hash{Symbol => Fixnum}] The text attributes codes by their
#   English name.
CLAide::ANSI::TEXT_ATTRIBUTES = T.let(T.unsafe(nil), Hash)

# @return [Hash{Symbol => Fixnum}] The codes to disable a text attribute by
#   their name.
CLAide::ANSI::TEXT_DISABLE_ATTRIBUTES = T.let(T.unsafe(nil), Hash)

# This class is responsible for parsing the parameters specified by the user,
# accessing individual parameters, and keep state by removing handled
# parameters.
class CLAide::ARGV
  # @param argv [Array<#to_s>] A list of parameters.
  # @return [ARGV] a new instance of ARGV
  def initialize(argv); end

  # @example
  #
  #   argv = CLAide::ARGV.new(['--ignore=foo', '--ignore=bar'])
  #   argv.all_options('include')  # => []
  #   argv.all_options('ignore')   # => ['bar', 'foo']
  #   argv.remainder               # => []
  # @note This will remove the option from the remaining parameters.
  # @param name [String] The name of the option to look for among the remaining
  #   parameters.
  # @return [Array<String>] Returns an array of all the values of the option
  #   with the specified `name` among the remaining
  #   parameters.
  def all_options(name); end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', 'white', '--no-milk', 'biscuit'])
  #   argv.shift_argument # => 'tea'
  #   argv.arguments      # => ['white', 'biscuit']
  # @return [Array<String>] A list of the remaining arguments.
  def arguments; end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', 'white', '--no-milk', 'biscuit'])
  #   argv.arguments  # => ['tea', 'white', 'biscuit']
  #   argv.arguments! # => ['tea', 'white', 'biscuit']
  #   argv.arguments  # => []
  # @note This version also removes the arguments from the remaining
  #   parameters.
  # @return [Array<String>] A list of the remaining arguments.
  def arguments!; end

  # @return [Boolean] Whether or not there are any remaining unhandled
  #   parameters.
  def empty?; end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', '--no-milk', '--sweetener=honey'])
  #   argv.flag?('milk')       # => false
  #   argv.flag?('milk')       # => nil
  #   argv.flag?('milk', true) # => true
  #   argv.remainder           # => ['tea', '--sweetener=honey']
  # @note This will remove the flag from the remaining parameters.
  # @param name [String] The name of the flag to look for among the remaining parameters.
  # @param default [Boolean] The value that is returned in case the flag is not among the
  #   remaining parameters.
  # @return [Boolean, nil] Returns `true` if the flag by the specified `name`
  #   is among the remaining parameters and is not negated.
  def flag?(name, default = T.unsafe(nil)); end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', '--no-milk', '--sweetener=honey'])
  #   argv.option('sweetener')          # => 'honey'
  #   argv.option('sweetener')          # => nil
  #   argv.option('sweetener', 'sugar') # => 'sugar'
  #   argv.remainder                   # => ['tea', '--no-milk']
  # @note This will remove the option from the remaining parameters.
  # @param name [String] The name of the option to look for among the remaining
  #   parameters.
  # @param default [String] The value that is returned in case the option is not among the
  #   remaining parameters.
  # @return [String, nil] Returns the value of the option by the specified
  #   `name` is among the remaining parameters.
  def option(name, default = T.unsafe(nil)); end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', '--no-milk', '--sweetener=honey'])
  #   argv.options # => { 'milk' => false, 'sweetener' => 'honey' }
  # @return [Hash] A hash that consists of the remaining flags and options
  #   and their values.
  def options; end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', '--no-milk', '--sweetener=honey'])
  #   argv.shift_argument # => 'tea'
  #   argv.remainder      # => ['--no-milk', '--sweetener=honey']
  # @return [Array<String>] A list of the remaining unhandled parameters, in
  #   the same format a user specifies it in.
  def remainder; end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', '--no-milk', '--sweetener=honey'])
  #   argv.shift_argument # => 'tea'
  #   argv.remainder!     # => ['--no-milk', '--sweetener=honey']
  #   argv.remainder      # => []
  # @return [Array<String>] A list of the remaining unhandled parameters, in
  #   the same format the user specified them.
  def remainder!; end

  # @example
  #
  #   argv = CLAide::ARGV.new(['tea', 'white'])
  #   argv.shift_argument # => 'tea'
  #   argv.arguments      # => ['white']
  # @note This will remove the argument from the remaining parameters.
  # @return [String] The first argument in the remaining parameters.
  def shift_argument; end

  private

  # @param requested_type [Symbol] The type of the entry.
  # @param requested_key [String] The key of the entry.
  # @param default [Bool, String, Nil] The value which should be returned if the entry is not present.
  # @param delete_all [Bool] Whether all values matching `requested_type` and `requested_key`
  #   should be deleted.
  # @return [Bool, String, Nil] Removes an entry from the entries list and
  #   returns its value or the default value if the entry was not
  #   present.
  def delete_entry(requested_type, requested_key, default, delete_all = T.unsafe(nil)); end

  # @return [Array<Array<Symbol, String, Array>>] A list of tuples for each
  #   non consumed parameter, where the first entry is the `type` and
  #   the second entry the actual parsed parameter.
  def entries; end

  class << self
    # @param argv [Object] The object which should be converted to the ARGV class.
    # @return [ARGV] Coerces an object to the ARGV class if needed.
    def coerce(argv); end
  end
end

module CLAide::ARGV::Parser
  class << self
    # @param argument [String] The argument to check.
    # @return [Symbol] Returns the type of an argument. The types can be
    #   either: `:arg`, `:flag`, `:option`.
    def argument_type(argument); end

    # @example
    #
    #   list = parse(['tea', '--no-milk', '--sweetener=honey'])
    #   list # => [[:arg, "tea"],
    #   [:flag, ["milk", false]],
    #   [:option, ["sweetener", "honey"]]]
    # @return [Array<Array<Symbol, String, Array>>] A list of tuples for each
    #   parameter, where the first entry is the `type` and the second
    #   entry the actual parsed parameter.
    def parse(argv); end

    # @param type [Symbol] The type of the argument.
    # @param argument [String] The argument to check.
    # @return [String, Array<String, String>] Returns the argument itself for
    #   normal arguments (like commands) and a tuple with the key and
    #   the value for options and flags.
    def parse_argument(type, argument); end

    # @param argument [String] The flag argument to check.
    # @return [String, Array<String, String>] Returns the parameter
    #   describing a flag arguments.
    def parse_flag(argument); end
  end
end

# This class is used to represent individual arguments to present to
# the command help banner
class CLAide::Argument
  # @example
  #
  #   # A required parameter that can be either a NAME or URL
  #   Argument.new(%(NAME URL), true)
  # @param names [String, Array<String>] List of the names of each parameter alternatives.
  #   For convenience, if there is only one alternative for that
  #   parameter, we can use a String instead of a 1-item Array
  # @param required [Boolean] true if the parameter is required, false if it is optional
  # @param repeatable [Boolean] If true, the argument can appear multiple times in the command.
  #   In that case, an ellipsis will be appended after the argument
  #   in the help banner.
  # @return [Argument] a new instance of Argument
  def initialize(names, required, repeatable = T.unsafe(nil)); end

  # @param other [Argument] the Argument compared against
  # @return [Boolean] true on equality
  def ==(other); end

  # @return [Array<String>] List of alternate names for the parameters
  def names; end

  # @return [Boolean] Indicates if the argument is repeatable (= can appear multiple
  #   times in the command, which is indicated by '...' in the banner)
  def repeatable; end

  # @return [Boolean] Indicates if the argument is repeatable (= can appear multiple
  #   times in the command, which is indicated by '...' in the banner)
  def repeatable=(_arg0); end

  # @return [Boolean] Indicates if the argument is repeatable (= can appear multiple
  #   times in the command, which is indicated by '...' in the banner)
  def repeatable?; end

  # @return [Boolean] Indicates if the argument is required (not optional)
  def required; end

  # @return [Boolean] Indicates if the argument is required (not optional)
  def required=(_arg0); end

  # @return [Boolean] Indicates if the argument is required (not optional)
  def required?; end
end

# The string used for ellipsis / repeatable arguments in the banner
CLAide::Argument::ELLIPSIS = T.let(T.unsafe(nil), String)

# This class is used to build a command-line interface
#
# Each command is represented by a subclass of this class, which may be
# nested to create more granular commands.
#
# Following is an overview of the types of commands and what they should do.
#
# ### Any command type
#
# * Inherit from the command class under which the command should be nested.
# * Set {Command.summary} to a brief description of the command.
# * Override {Command.options} to return the options it handles and their
#   descriptions and prepending them to the results of calling `super`.
# * Override {Command#initialize} if it handles any parameters.
# * Override {Command#validate!} to check if the required parameters the
#   command handles are valid, or call {Command#help!} in case they’re not.
#
# ### Abstract command
#
# The following is needed for an abstract command:
#
# * Set {Command.abstract_command} to `true`.
# * Subclass the command.
#
# When the optional {Command.description} is specified, it will be shown at
# the top of the command’s help banner.
#
# ### Normal command
#
# The following is needed for a normal command:
#
# * Set {Command.arguments} to the description of the arguments this command
#   handles.
# * Override {Command#run} to perform the actual work.
#
# When the optional {Command.description} is specified, it will be shown
# underneath the usage section of the command’s help banner. Otherwise this
# defaults to {Command.summary}.
class CLAide::Command
  # Subclasses should override this method to remove the arguments/options
  # they support from `argv` _before_ calling `super`.
  #
  # The `super` implementation sets the {#verbose} attribute based on whether
  # or not the `--verbose` option is specified; and the {#ansi_output}
  # attribute to `false` if {Command.ansi_output} returns `true`, but the
  # user specified the `--no-ansi` option.
  #
  # @param argv [ARGV, Array] A list of (user-supplied) params that should be handled.
  # @return [Command] a new instance of Command
  def initialize(argv); end

  # Set to `true` if {Command.ansi_output} returns `true` and the user
  # did **not** specify the `--no-ansi` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Whether or not to use ANSI codes to prettify output. For instance, by
  #   default {InformativeError} exception messages will be colored red and
  #   subcommands in help banners green.
  def ansi_output; end

  # Set to `true` if {Command.ansi_output} returns `true` and the user
  # did **not** specify the `--no-ansi` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Whether or not to use ANSI codes to prettify output. For instance, by
  #   default {InformativeError} exception messages will be colored red and
  #   subcommands in help banners green.
  def ansi_output=(_arg0); end

  # Set to `true` if {Command.ansi_output} returns `true` and the user
  # did **not** specify the `--no-ansi` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Whether or not to use ANSI codes to prettify output. For instance, by
  #   default {InformativeError} exception messages will be colored red and
  #   subcommands in help banners green.
  def ansi_output?; end

  # Handles root commands options if appropriate.
  #
  # @param argv [ARGV] The parameters of the command.
  # @return [Bool] Whether any root command option was handled.
  def handle_root_options(argv); end

  # Set to `true` if initialized with a `--help` flag
  #
  # @return [Boolean] Whether the command was initialized with argv containing --help
  def help?; end

  # Set to `true` if initialized with a `--help` flag
  #
  # @return [Boolean] Whether the command was initialized with argv containing --help
  def help_arg; end

  # Set to `true` if initialized with a `--help` flag
  #
  # @return [Boolean] Whether the command was initialized with argv containing --help
  def help_arg=(_arg0); end

  # @return [Bool] Whether the command was invoked by an abstract command by
  #   default.
  def invoked_as_default; end

  # @return [Bool] Whether the command was invoked by an abstract command by
  #   default.
  def invoked_as_default=(_arg0); end

  # @return [Bool] Whether the command was invoked by an abstract command by
  #   default.
  def invoked_as_default?; end

  # Prints the version of the command optionally including plugins.
  def print_version; end

  # This method should be overridden by the command class to perform its
  # work.
  #
  # @return [void]
  def run; end

  # Raises a Help exception if the `--help` option is specified, if `argv`
  # still contains remaining arguments/options by the time it reaches this
  # implementation, or when called on an ‘abstract command’.
  #
  # Subclasses should call `super` _before_ doing their own validation. This
  # way when the user specifies the `--help` flag a help banner is shown,
  # instead of possible actual validation errors.
  #
  # @raise [Help]
  # @return [void]
  def validate!; end

  # Set to `true` if the user specifies the `--verbose` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Wether or not backtraces should be included when presenting the user an
  #   exception that includes the {InformativeError} module.
  def verbose; end

  # Set to `true` if the user specifies the `--verbose` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Wether or not backtraces should be included when presenting the user an
  #   exception that includes the {InformativeError} module.
  def verbose=(_arg0); end

  # Set to `true` if the user specifies the `--verbose` option.
  #
  # @note If you want to make use of this value for your own configuration, you
  #   should check the value _after_ calling the `super` {Command#initialize}
  #   implementation.
  # @return [Boolean] Wether or not backtraces should be included when presenting the user an
  #   exception that includes the {InformativeError} module.
  def verbose?; end

  protected

  # Print banner and exit
  #
  # @note Calling this method exits the current process.
  # @return [void]
  def banner!; end

  # @param error_message [String] A custom optional error message
  # @raise [Help] Signals CLAide that a help banner for this command should be shown,
  #   with an optional error message.
  # @return [void]
  def help!(error_message = T.unsafe(nil)); end

  # Returns the class of the invoked command
  #
  # @return [Command]
  def invoked_command_class; end

  class << self
    # @return [Boolean] Indicates whether or not this command can actually
    #   perform work of itself, or that it only contains subcommands.
    def abstract_command; end

    # @return [Boolean] Indicates whether or not this command can actually
    #   perform work of itself, or that it only contains subcommands.
    def abstract_command=(_arg0); end

    # @return [Boolean] Indicates whether or not this command can actually
    #   perform work of itself, or that it only contains subcommands.
    def abstract_command?; end

    # @return [Boolean] The default value for {Command#ansi_output}. This
    #   defaults to `true` if `STDOUT` is connected to a TTY and
    #   `String` has the instance methods `#red`, `#green`, and
    #   `#yellow` (which are defined by, for instance, the
    #   [colored](https://github.com/defunkt/colored) gem).
    def ansi_output; end

    # Sets the attribute ansi_output
    #
    # @param value the value to set the attribute ansi_output to.
    def ansi_output=(_arg0); end

    # @return [Boolean] The default value for {Command#ansi_output}. This
    #   defaults to `true` if `STDOUT` is connected to a TTY and
    #   `String` has the instance methods `#red`, `#green`, and
    #   `#yellow` (which are defined by, for instance, the
    #   [colored](https://github.com/defunkt/colored) gem).
    def ansi_output?; end

    # @return [Array<Argument>] A list of arguments the command handles. This is shown
    #   in the usage section of the command’s help banner.
    #   Each Argument in the array represents an argument by its name
    #   (or list of alternatives) and whether it's required or optional
    def arguments; end

    # @param arguments [Array<Argument>] An array listing the command arguments.
    #   Each Argument object describe the argument by its name
    #   (or list of alternatives) and whether it's required or optional
    # @todo Remove deprecation
    def arguments=(arguments); end

    # Handle deprecated form of self.arguments as an
    # Array<Array<(String, Symbol)>> like in:
    #
    #   self.arguments = [ ['NAME', :required], ['QUERY', :optional] ]
    #
    # @todo Remove deprecated format support
    def arguments_array=(arguments); end

    # Handle deprecated form of self.arguments as a String, like in:
    #
    #   self.arguments = 'NAME [QUERY]'
    #
    # @todo Remove deprecated format support
    def arguments_string=(arguments); end

    # Returns the banner for the command.
    #
    # @param banner_class [Class] The class to use to format help banners.
    # @return [String] The banner for the command.
    def banner(banner_class = T.unsafe(nil)); end

    # Print banner and exit
    #
    # @note Calling this method exits the current process.
    # @return [void]
    def banner!; end

    # @return [String] The name of the command. Defaults to a snake-cased
    #   version of the class’ name.
    def command; end

    # Sets the attribute command
    #
    # @param value the value to set the attribute command to.
    def command=(_arg0); end

    # @return [String] The subcommand which an abstract command should invoke
    #   by default.
    def default_subcommand; end

    # @return [String] The subcommand which an abstract command should invoke
    #   by default.
    def default_subcommand=(_arg0); end

    # @return [String] A longer description of the command, which is shown
    #   underneath the usage section of the command’s help banner. Any
    #   indentation in this value will be ignored.
    def description; end

    # @return [String] A longer description of the command, which is shown
    #   underneath the usage section of the command’s help banner. Any
    #   indentation in this value will be ignored.
    def description=(_arg0); end

    # Searches the list of subcommands that should not be ignored for command
    # lookup for a subcommand with the given `name`.
    #
    # @param name [String] The name of the subcommand to be found.
    # @return [CLAide::Command, nil] The subcommand, if found.
    def find_subcommand(name); end

    # @example
    #
    #   BevarageMaker::Tea.full_command # => "beverage-maker tea"
    # @return [String] The full command up-to this command, as it would be
    #   looked up during parsing.
    def full_command; end

    # Presents an exception to the user in a short manner in case of an
    # `InformativeError` or in long form in other cases,
    #
    # @param command [Command, nil] The command from where the exception originated.
    # @param exception [Object] The exception to present.
    # @return [void]
    def handle_exception(command, exception); end

    # @param error_message [String] The error message to show to the user.
    # @param help_class [Class] The class to use to raise a ‘help’ error.
    # @raise [Help] Signals CLAide that a help banner for this command should be shown,
    #   with an optional error message.
    # @return [void]
    def help!(error_message = T.unsafe(nil), help_class = T.unsafe(nil)); end

    # @return [Boolean] Indicates whether or not this command is used during
    #   command parsing and whether or not it should be shown in the
    #   help banner or to show its subcommands instead.
    #
    #   Setting this to `true` implies it’s an abstract command.
    def ignore_in_command_lookup; end

    def ignore_in_command_lookup=(flag); end

    # @return [Boolean] Indicates whether or not this command is used during
    #   command parsing and whether or not it should be shown in the
    #   help banner or to show its subcommands instead.
    #
    #   Setting this to `true` implies it’s an abstract command.
    def ignore_in_command_lookup?; end

    # Automatically registers a subclass as a subcommand.
    def inherited(subcommand); end

    # Convenience method.
    # Instantiate the command and run it with the provided arguments at once.
    #
    # CLAide::Command::run, it does not load plugins nor exit on failure.
    # It is up to the caller to rescue any possible exception raised.
    #
    # @note This method validate! the command before running it, but contrary to
    # @param args [String..., Array<String>] The arguments to initialize the command with
    # @raise [Help] If validate! fails
    def invoke(*args); end

    # @param argv [Array, ARGV] A list of (remaining) parameters.
    # @return [Command] Returns the default subcommand initialized with the
    #   given arguments.
    def load_default_subcommand(argv); end

    # Should be overridden by a subclass if it handles any options.
    #
    # The subclass has to combine the result of calling `super` and its own
    # list of options. The recommended way of doing this is by concatenating
    # to this classes’ own options.
    #
    # @example
    #
    #   def self.options
    #   [
    #   ['--verbose', 'Print more info'],
    #   ['--help',    'Print help banner'],
    #   ].concat(super)
    #   end
    # @return [Array<Array>] A list of option name and description tuples.
    def options; end

    # @param argv [Array, ARGV] A list of (remaining) parameters.
    # @return [Command] An instance of the command class that was matched by
    #   going through the arguments in the parameters and drilling down
    #   command classes.
    def parse(argv); end

    # Handle depracted form of assigning a plugin prefix.
    #
    # @todo Remove deprecated form.
    def plugin_prefix=(prefix); end

    # @return [Array<String>] The prefixes used to search for CLAide plugins.
    #   Plugins are loaded via their `<plugin_prefix>_plugin.rb` file.
    #   Defaults to search for `claide` plugins.
    def plugin_prefixes; end

    # Sets the attribute plugin_prefixes
    #
    # @param value the value to set the attribute plugin_prefixes to.
    def plugin_prefixes=(_arg0); end

    # Allows the application to perform custom error reporting, by overriding
    # this method.
    #
    # @param exception [Exception] An exception that occurred while running a command through
    #   {Command.run}.
    # @raise By default re-raises the specified exception.
    # @return [void]
    def report_error(exception); end

    # @return [Bool] Whether this is the root command class
    def root_command?; end

    # Instantiates the command class matching the parameters through
    # {Command.parse}, validates it through {Command#validate!}, and runs it
    # through {Command#run}.
    #
    # @note The ANSI support is configured before running a command to allow
    #   the same process to run multiple commands with different
    #   settings.  For example a process with ANSI output enabled might
    #   want to programmatically invoke another command with the output
    #   enabled.
    # @param argv [Array, ARGV] A list of parameters. For instance, the standard `ARGV` constant,
    #   which contains the parameters passed to the program.
    # @return [void]
    def run(argv = T.unsafe(nil)); end

    # @return [Array<Class>] A list of all command classes that are nested
    #   under this command.
    def subcommands; end

    # @return [Array<Class>] A list of command classes that are nested under
    #   this command _or_ the subcommands of those command classes in
    #   case the command class should be ignored in command lookup.
    def subcommands_for_command_lookup; end

    # @return [String] A brief description of the command, which is shown
    #   next to the command in the help banner of a parent command.
    def summary; end

    # @return [String] A brief description of the command, which is shown
    #   next to the command in the help banner of a parent command.
    def summary=(_arg0); end

    # @return [String] The version of the command. This value will be printed
    #   by the `--version` flag if used for the root command.
    def version; end

    # @return [String] The version of the command. This value will be printed
    #   by the `--version` flag if used for the root command.
    def version=(_arg0); end

    private

    # Adds a new option for the current command.
    #
    # This method can be used in conjunction with overriding `options`.
    #
    # @example
    #
    #   option '--help', 'Print help banner '
    # @return [void]
    def option(name, description); end
  end
end

class CLAide::Command::ArgumentSuggester
  # @param argument [String] The unrecognized argument for which to make a suggestion.
  # @param command_class [Class] The class of the command which encountered the unrecognized
  #   arguments.
  # @return [ArgumentSuggester] a new instance of ArgumentSuggester
  def initialize(argument, command_class); end

  # @return [Array<String>] The list of the valid arguments for a command
  #   according to the type of the argument.
  def possibilities; end

  # @return [String] Returns a suggested argument from `possibilities` based
  #   on the `levenshtein_distance` score.
  def suggested_argument; end

  # @return [String] Returns a message including a suggestion for the given
  #   suggestion.
  def suggestion; end

  class << self
    # Returns the Levenshtein distance between the given strings.
    # From: http://rosettacode.org/wiki/Levenshtein_distance#Ruby
    #
    # @param a [String] The first string to compare.
    # @param b [String] The second string to compare.
    # @return [Fixnum] The distance between the strings.
    def levenshtein_distance(a, b); end

    # Prettifies the given validation suggestion according to the type.
    #
    # @param suggestion [String] The suggestion to prettify.
    # @param argument_type [Type] The type of the suggestion: either `:command` or `:option`.
    # @return [String] A handsome suggestion.
    def prettify_suggestion(suggestion, argument_type); end
  end
end

# Creates the formatted banner to present as help of the provided command
# class.
class CLAide::Command::Banner
  # @param command [Class] @see command
  # @return [Banner] a new instance of Banner
  def initialize(command); end

  # @return [Class] The command for which the banner should be created.
  def command; end

  # @return [Class] The command for which the banner should be created.
  def command=(_arg0); end

  # @return [String] The banner for the command.
  def formatted_banner; end

  private

  # @return [Fixnum] The width of the largest command name or of the
  #   largest option name. Used to align all the descriptions.
  def compute_max_name_width; end

  # @return [String] The line describing a single entry (subcommand or
  #   option).
  def entry_description(name, description, name_width); end

  # @return [String] The section describing the options of the command.
  def formatted_options_description; end

  # @note The plus sign emphasizes the that the subcommands are added to
  #   the command. The square brackets conveys a sense of direction
  #   and indicates the gravitational force towards the default
  #   command.
  # @return [String] The section describing the subcommands of the command.
  def formatted_subcommand_summaries; end

  # @return [String] The section describing the usage of the command.
  def formatted_usage_description; end

  # @return [String] A decorated command description.
  def prettify_message(command, message); end

  # @return [String] A decorated textual representation of the option name.
  def prettify_option_name(name); end

  # @return [String] A decorated textual representation of the command.
  def prettify_signature(command, subcommand, argument); end

  # @return [String] A decorated textual representation of the subcommand
  #   name.
  def prettify_subcommand(name); end

  # @return [String] A decorated title.
  def prettify_title(title); end

  # @return [String] The signature of the command.
  def signature; end

  # @return [String] The arguments of the signature.
  def signature_arguments; end

  # @return [String] The subcommand indicator of the signature.
  def signature_sub_command; end

  # @return [Array<String>] The list of the subcommands to use in the
  #   banner.
  def subcommands_for_banner; end
end

# @return [Fixnum] The minimum between a name and its description.
CLAide::Command::Banner::DESCRIPTION_SPACES = T.let(T.unsafe(nil), Integer)

# @return [Fixnum] The maximum width of the text.
CLAide::Command::Banner::MAX_WIDTH = T.let(T.unsafe(nil), Integer)

# @return [Fixnum] The minimum between a name and its description.
CLAide::Command::Banner::SUBCOMMAND_BULLET_SIZE = T.let(T.unsafe(nil), Integer)

# @return [String] The indentation of the text.
CLAide::Command::Banner::TEXT_INDENT = T.let(T.unsafe(nil), Integer)

module CLAide::Command::Banner::TextWrapper
  class << self
    # @return [String] Lifted straight from ActiveSupport. Thanks guys!
    def strip_heredoc(string); end

    # @return [Fixnum] The width of the current terminal unless being piped.
    def terminal_width; end

    # @return [String] Lifted straight from ActionView. Thanks guys!
    def word_wrap(line, line_width); end

    # @param string [String] The string to format.
    # @param indent [Fixnum] The number of spaces to insert before the string.
    # @param max_width [Fixnum] The maximum width to use to format the string if the terminal
    #   is too wide.
    # @return [String] Wraps a formatted string (e.g. markdown) by stripping
    #   heredoc indentation and wrapping by word to the terminal width
    #   taking into account a maximum one, and indenting the string.
    #   Code lines (i.e. indented by four spaces) are not wrapped.
    def wrap_formatted_text(string, indent = T.unsafe(nil), max_width = T.unsafe(nil)); end

    # @param string [String] The string to indent.
    # @param indent [Fixnum] The number of spaces to insert before the string.
    # @param max_width [Fixnum] The maximum width to use to format the string if the terminal
    #   is too wide.
    # @return [String] Wraps a string to the terminal width taking into
    #   account the given indentation.
    def wrap_with_indent(string, indent = T.unsafe(nil), max_width = T.unsafe(nil)); end

    private

    def calculate_terminal_width; end
  end
end

CLAide::Command::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Array)
CLAide::Command::DEFAULT_ROOT_OPTIONS = T.let(T.unsafe(nil), Array)

# Handles plugin related logic logic for the `Command` class.
#
# Plugins are loaded the first time a command run and are identified by the
# prefix specified in the command class. Plugins must adopt the following
# conventions:
#
# - Support being loaded by a file located under the
# `lib/#{plugin_prefix}_plugin` relative path.
# - Be stored in a folder named after the plugin.
class CLAide::Command::PluginManager
  class << self
    # @return [Array<Specification>] The RubyGems specifications for the
    #   installed plugins that match the given `plugin_prefix`.
    def installed_specifications_for_prefix(plugin_prefix); end

    # @return [Array<Gem::Specification>] Loads plugins via RubyGems looking
    #   for files named after the `PLUGIN_PREFIX_plugin` and returns the
    #   specifications of the gems loaded successfully.
    #   Plugins are required safely.
    def load_plugins(plugin_prefix); end

    # @return [Hash<String,Gem::Specification>] The loaded plugins,
    #   grouped by plugin prefix.
    def loaded_plugins; end

    # @return [Array<[Gem::Specification, Array<String>]>] Returns an array of tuples containing the specifications and
    #   plugin files to require for a given plugin prefix.
    def plugin_gems_for_prefix(prefix); end

    # @param exception [Exception] The exception to analyze.
    # @return [Array<String>] The list of the plugins whose root path appears
    #   in the backtrace of an exception.
    def plugins_involved_in_exception(exception); end

    # Requires the given paths.
    # If any exception occurs it is caught and an
    # informative message is printed.
    #
    # @param paths [String] The paths to require.
    # @return [Bool] Whether requiring succeeded.
    def safe_require(paths); end

    # @return [Array<Specification>] The RubyGems specifications for the
    #   loaded plugins.
    def specifications; end

    private

    def full_require_paths_for(gemspec); end
  end
end

# The exception class that is raised to indicate a help banner should be
# shown while running {Command.run}.
class CLAide::Help < ::StandardError
  include ::CLAide::InformativeError

  # @note If an error message is provided, the exit status, used to
  #   terminate the program with, will be set to `1`, otherwise a {Help}
  #   exception is treated as not being a real error and exits with `0`.
  # @param banner [String] @see banner
  # @param error_message [String] @see error_message
  # @return [Help] a new instance of Help
  def initialize(banner, error_message = T.unsafe(nil)); end

  # command to show in the help.
  #
  # @return [String] The banner containing the usage instructions of the
  def banner; end

  # @return [String] An optional error message that will be shown before the
  #   help banner.
  def error_message; end

  # @return [String] The optional error message, colored in red if
  #   {Command.ansi_output} is set to `true`.
  def formatted_error_message; end

  # @return [String] The optional error message, combined with the help
  #   banner of the command.
  def message; end

  # @return [String]
  def prettify_error_message(message); end
end

# Including this module into an exception class will ensure that when raised,
# while running {Command.run}, only the message of the exception will be
# shown to the user. Unless disabled with the `--verbose` flag.
#
# In addition, the message will be colored red, if {Command.ansi_output}
# is set to `true`.
module CLAide::InformativeError
  def exit_status; end

  # @return [Numeric] The exist status code that should be used to terminate
  #   the program with. Defaults to `1`.
  def exit_status=(_arg0); end
end

# Enhance the String class with a XML escaped character version of
# to_s.
class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Colored2
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  # @example
  #
  #   "example".ansi.yellow #=> "\e[33mexample\e[39m"
  #   "example".ansi.on_red #=> "\e[41mexample\e[49m"
  #   "example".ansi.bold   #=> "\e[1mexample\e[21m"
  # @return [StringEscaper] An object which provides convenience methods to
  #   wrap the receiver in ANSI sequences.
  def ansi; end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
