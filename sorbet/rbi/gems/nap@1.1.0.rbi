# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `nap` gem.
# Please instead update this file by running `bin/tapioca gem nap`.

# REST is basically a convenience wrapper around Net::HTTP. It defines a simple and consistant API
# for doing REST-style HTTP calls.
#
# In addition it provides wrappers for the many error classes that can be raised while making
# requests. See REST::Error for a complete discussion of options.
module REST
  class << self
    # Performs a DELETE on a resource. See REST::Request.new for a complete discussion of options.
    #
    #   response = REST.delete('http://example.com/pigeons/12')
    #   if response.ok?
    #     puts "Your pigeon died ): )"
    #   elsif response.found?
    #     puts "Someone moved your pigeon!"
    #   else
    #     puts "Couldn't delete your pigeon (#{response.status_code})"
    #   end
    def delete(uri, headers = T.unsafe(nil), options = T.unsafe(nil), &configure_block); end

    # Performs a GET on a resource. See REST::Request.new for a complete discussion of options.
    #
    #   response = REST.get('http://example.com/pigeons/12',
    #     {'Accept' => 'text/plain'},
    #     {:username => 'admin', :password => 'secret'}
    #   )
    #   if response.ok?
    #     puts response.body
    #   else
    #     puts "Couldn't fetch your pigeon (#{response.status_code})"
    #   end
    def get(uri, headers = T.unsafe(nil), options = T.unsafe(nil), &configure_block); end

    # Performs a HEAD on a resource. See REST::Request.new for a complete discussion of options.
    #
    #   response = REST.head('http://example.com/pigeons/12')
    #   if response.ok?
    #     puts "Your pigeon exists!"
    #   elsif response.found?
    #     puts "Someone moved your pigeon!"
    #   else
    #     puts "Couldn't fetch your pigeon (#{response.status_code})"
    #   end
    def head(uri, headers = T.unsafe(nil), options = T.unsafe(nil), &configure_block); end

    # Performs a PATCH on a resource. See REST::Request.new for a complete discussion of options.
    #
    #   response = REST.patch('http://example.com/pigeons/12',
    #     {'Name' => 'Homer'}.to_xml,
    #     {'Accept' => 'application/xml, */*', 'Content-Type' => 'application/xml'}
    #   )
    #   if response.ok?
    #     puts "Your pigeon was renamed to 'Homer'!"
    #   else
    #     puts "Couldn't rename your pigeon (#{response.status_code})"
    #     puts XML.parse(response.body).reason
    #   end
    def patch(uri, body, headers = T.unsafe(nil), options = T.unsafe(nil), &configure_block); end

    # Performs a POST on a resource. See REST::Request.new for a complete discussion of options.
    #
    #   response = REST.post('http://example.com/pigeons',
    #     {'Name' => 'Bowser'}.to_xml,
    #     {'Accept' => 'application/xml, */*', 'Content-Type' => 'application/xml'}
    #   )
    #   if response.created?
    #     puts "Created a new pigeon called 'Bowser'"
    #   else
    #     puts "Couldn't create your pigeon (#{response.status_code})"
    #     puts XML.parse(response.body).reason
    #   end
    def post(uri, body, headers = T.unsafe(nil), options = T.unsafe(nil), &configure_block); end

    # Performs a PUT on a resource. See REST::Request.new for a complete discussion of options.
    #
    #   response = REST.put('http://example.com/pigeons/12',
    #     {'Name' => 'Homer'}.to_xml,
    #     {'Accept' => 'application/xml, */*', 'Content-Type' => 'application/xml'}
    #   )
    #   if response.ok?
    #     puts "Your pigeon 'Bowser' was replaced by 'Homer'!"
    #   else
    #     puts "Couldn't replace your pigeon (#{response.status_code})"
    #     puts XML.parse(response.body).reason
    #   end
    def put(uri, body, headers = T.unsafe(nil), options = T.unsafe(nil), &configure_block); end
  end
end

# This constant can be used to rescue any of the known `Timeout`, `Connection`, and `Protocol`
# error classes.
#
# For instance, to rescue _any_ type of error that could be raise while making a request:
#
#   begin
#     REST.get('http://example.com/pigeons/12')
#   rescue REST::Error => e
#     p e # => Timeout::Error
#   end
#
# If you want to rescue only `Timeout` related error classes, however, you can limit the scope:
#
#   begin
#     REST.get('http://example.com/pigeons/12')
#   rescue REST::Error::Timeout => e
#     p e # => Timeout::Error
#   end
module REST::Error; end

# This constant can be used to rescue only the known `Connection` error classes.
module REST::Error::Connection
  include ::REST::Error

  class << self
    def class_names; end
    def classes; end
    def extend_classes!; end
  end
end

# This constant can be used to rescue only the known `Protocol` error classes.
module REST::Error::Protocol
  include ::REST::Error

  class << self
    def class_names; end
    def classes; end
    def extend_classes!; end
  end
end

# This constant can be used to rescue only the known `Timeout` error classes.
module REST::Error::Timeout
  include ::REST::Error

  class << self
    def class_names; end
    def classes; end
    def extend_classes!; end
  end
end

# Request holds a HTTP request
class REST::Request
  # * <tt>verb</tt>: The verb to use in the request, either :get, :head, :patch, :put, or :post
  # * <tt>url</tt>: The URL to send the request to, must be a URI instance
  # * <tt>body</tt>: The body to use in the request
  # * <tt>headers</tt>: A hash of headers to add to the request
  # * <tt>options</tt>: A hash of additional options
  #   * <tt>username</tt>: Username to use for basic authentication
  #   * <tt>password</tt>: Password to use for basic authentication
  #   * <tt>tls_verify/verify_ssl</tt>: Verify the server certificate against known CA's
  #   * <tt>tls_ca_file</tt>: Use a specific file for CA certificates instead of the built-in one
  #     this only works when <tt>:tls_verify</tt> is also set.
  #   * <tt>tls_key_and_certificate_file</tt>: The client key and certificate file to use for this
  #     request
  #   * <tt>tls_certificate</tt>: The client certficate to use for this request
  #   * <tt>tls_key</tt>: The client private key to use for this request
  # * <tt>configure_block</tt>: An optional block that yields the underlying <tt>Net::HTTP</tt>
  #   request object allowing for more fine-grained configuration
  #
  # == Examples
  #
  #   request = REST::Request.new(:get, URI.parse('http://example.com/pigeons/1'))
  #
  #   request = REST::Request.new(:head, URI.parse('http://example.com/pigeons/1'))
  #
  #   request = REST::Request.new(:post,
  #     URI.parse('http://example.com/pigeons'),
  #     {'name' => 'Homr'}.to_json,
  #     {'Accept' => 'application/json, */*', 'Content-Type' => 'application/json; charset=utf-8'}
  #   )
  #
  #   # Pass a block to configure the underlying +Net::HTTP+ request.
  #   request = REST::Request.new(:get, URI.parse('http://example.com/pigeons/largest')) do |http_request|
  #     http_request.open_timeout = 15 # seconds
  #   end
  #
  # == Authentication example
  #
  #   request = REST::Request.new(:put,
  #     URI.parse('http://example.com/pigeons/1'),
  #     {'name' => 'Homer'}.to_json,
  #     {'Accept' => 'application/json, */*', 'Content-Type' => 'application/json; charset=utf-8'},
  #     {:username => 'Admin', :password => 'secret'}
  #   )
  #
  # == TLS / SSL examples
  #
  #   # Use a client key and certificate
  #   request = REST::Request.new(:get, URI.parse('https://example.com/pigeons/1'), nil, {}, {
  #     :tls_key_and_certificate_file => '/home/alice/keys/example.pem'
  #   })
  #
  #   # Use a client certificate and key from a specific location
  #   key_and_certificate = File.read('/home/alice/keys/example.pem')
  #   request = REST::Request.new(:get, URI.parse('https://example.com/pigeons/1'), nil, {}, {
  #     :tls_key => OpenSSL::PKey::RSA.new(key_and_certificate),
  #     :tls_certificate => OpenSSL::X509::Certificate.new(key_and_certificate)
  #   })
  #
  #   # Verify the server certificate against a specific certificate
  #   request = REST::Request.new(:get, URI.parse('https://example.com/pigeons/1'), nil, {}, {
  #     :tls_verify => true,
  #     :tls_ca_file => '/home/alice/keys/example.pem'
  #   })
  #
  # @return [Request] a new instance of Request
  def initialize(verb, url, body = T.unsafe(nil), headers = T.unsafe(nil), options = T.unsafe(nil), &configure_block); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  # Returns the value of attribute headers.
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  def headers=(_arg0); end

  def http_proxy; end

  # Configures and returns a new <tt>Net::HTTP</tt> request object
  def http_request; end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Returns the path (including the query) for the request
  def path; end

  # Performs the actual request and returns a REST::Response object with the response
  def perform; end

  def proxy_env; end
  def proxy_settings; end

  # Returns the value of attribute request.
  def request; end

  # Sets the attribute request
  #
  # @param value the value to set the attribute request to.
  def request=(_arg0); end

  def request_for_verb; end

  # Returns the value of attribute url.
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  def url=(_arg0); end

  # Returns the value of attribute verb.
  def verb; end

  # Sets the attribute verb
  #
  # @param value the value to set the attribute verb to.
  def verb=(_arg0); end

  class << self
    # Shortcut for REST::Request.new(*args).perform.
    #
    # See new for options.
    def perform(*args, &configure_block); end
  end
end

# Response holds a HTTP response
class REST::Response
  # * <tt>status_code</tt>: The status code of the response (ie. 200 or '404')
  # * <tt>headers</tt>: The headers of the response
  # * <tt>body</tt>: The body of the response
  #
  # @return [Response] a new instance of Response
  def initialize(status_code, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  def bad_request?; end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  def created?; end
  def forbidden?; end
  def found?; end

  # Returns the value of attribute headers.
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  def headers=(_arg0); end

  def internal_server_error?; end
  def moved_permanently?; end
  def not_found?; end
  def ok?; end

  # Returns the value of attribute status_code.
  def status_code; end

  # Sets the attribute status_code
  #
  # @param value the value to set the attribute status_code to.
  def status_code=(_arg0); end

  # Returns _true_ when the status code is in the 2XX range. Returns false otherwise.
  #
  # @return [Boolean]
  def success?; end

  def unauthorized?; end
  def unprocessable_entity?; end
end

# These codes are used to define convenience boolean accessors on the response object.
#
# Examples
#
#   REST::Response.new(200).ok? #=> true
#   REST::Response.new(201).ok? #=> falses
#   REST::Response.new(403).forbidden? #=> true
REST::Response::CODES = T.let(T.unsafe(nil), Array)

# Library version
REST::VERSION = T.let(T.unsafe(nil), String)
